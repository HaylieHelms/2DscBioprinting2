---
title: "VHD_scPrint2-HE_Analysis - Publication"
author: "Haylie Helms"
date: "2025-06-10"
output:
  html_document: default
  pdf_document:
    latex_engine: xelatex
    keep_tex: true
geometry: margin=1in
fontsize: 11pt
mainfont: Arial
monofont: Arial
header-includes:
  - \usepackage{microtype}
  - \usepackage{xurl}
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines=true,breakanywhere=true,commandchars=\\\{\}}
  - \sloppy
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "E:/Haylie/VHD_scPrint2-HE/AnalysisOuts/Jan26")
```

```{r message=FALSE, warning=FALSE}
library(Seurat)
library(tidyverse)
library(tibble)
library(stringr)
library(ggplot2)
library(patchwork)
library(scales)
library(ggpubr) 
library(Matrix)
library(arrow)
library(magick)
library(grid)
library(clusterProfiler)
library(org.Hs.eg.db)
library(msigdbr)
library(escape)
library(ComplexHeatmap) 
library(circlize)
library(knitr)
library(tinytex)
```

# Getting started: Load Data & Curate Metadata
```{r}
#c(2,8,16)) for all binning sizes

Slide1_A1 <- Load10X_Spatial(data.dir = "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide1_A1_OUTS/outs", bin.size = c(8), slice = "Slide1_A1") 

Slide2_D1 <- Load10X_Spatial(data.dir = "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide2_D1_OUTS/outs", bin.size = c(8), slice = "Slide2_D1") 
```

## 1.) Add original slide information to the metadata orig.ident
```{r}
Slide1_A1@meta.data$orig.ident <- "Slide1_A1"

head(Slide1_A1)

Slide2_D1@meta.data$orig.ident <- "Slide2_D1"

head(Slide2_D1)
```

```{r}
Slide1_A1@meta.data$CaptureArea <- "Slide1_A1"

head(Slide1_A1)

Slide2_D1@meta.data$CaptureArea <- "Slide2_D1"

head(Slide2_D1)
```

## 2.) Add cell type annotations
Cell type labels are generated via manual annotation in Loupe Browser using the selection tool (freehand, rectangle, or paintbrush) and "Custom Groups" --> Download barcode groupings as .csv --> included unlabeled. Complete details for this process can be found in our STAR protocol: https://star-protocols.cell.com/protocols/4456

My samples have fluorescent tags in it so that the nucleus or cell body has a unique color. Since Loupe (and space ranger to generate a Loupe file) do not allow multiple images to be loaded in at a time, I use a custom overlay software (https://zenodo.org/records/10511395) which has adjustable opacity so I can look at both images at the same time. By toggling between the images I can manually annotate each cell using the paintbrush tool in Loupe. 

NOTE: Visium HD WT, the kit used here, doesn't allow for custom references during FASTQ processing. The new VHD 3' kit lets you include GFP, RFP, etc which can then be used to automatically annotate the transduced cells. 

```{r}
# Slide 1 A1

# Load the CSV, ensuring the Barcode column becomes row names
A1_Phenotype_df <- read.csv("E:/Haylie/VHD_scPrint2-HE/S1A1_CellType_ALLPRINTS.csv", row.names = 1)

# If there isn't an assigned cell type  add "Unlabeled"
A1_Phenotype_df$CellType[A1_Phenotype_df$CellType == "" | is.na(A1_Phenotype_df$CellType)] <- "Unlabeled"

unique(A1_Phenotype_df$CellType)

head(A1_Phenotype_df)

# Make sure that the barcode is the rowname of the Barcode_Anns file
#rownames(A1_Phenotype_df) <- A1_Phenotype_df$Barcode

# get rid of the duplicate barcode column if necessary
#A1_Phenotype_df$Barcode <- NULL

# head(A1_Phenotype_df)

Slide1_A1 <- AddMetaData(Slide1_A1, metadata = A1_Phenotype_df)

head(Slide1_A1)

# Confirm no missing annotations
sum(is.na(Slide1_A1@meta.data$CellType))
```

```{r}
# Slide 2 D1

# Load the CSV, ensuring the Barcode column becomes row names
D1_Phenotype_df <- read.csv("E:/Haylie/VHD_scPrint2-HE/S2D1_cellType_ALLPRINTS.csv", row.names = 1)

# If there isn't an assigned cell type  add "Unlabeled"
D1_Phenotype_df$CellType[D1_Phenotype_df$CellType == "" | is.na(D1_Phenotype_df$CellType)] <- "Unlabeled"

unique(D1_Phenotype_df$CellType)

head(D1_Phenotype_df)

# Make sure that the barcode is the rowname of the Barcode_Anns file
#rownames(D1_Phenotype_df) <- D1_Phenotype_df$Barcode

# get rid of the duplicate barcode
#D1_Phenotype_df$Barcode <- NULL

# head(D1_Phenotype_df)

Slide2_D1 <- AddMetaData(Slide2_D1, metadata = D1_Phenotype_df)

head(Slide2_D1)

# Confirm no missing annotations
sum(is.na(Slide2_D1@meta.data$CellType))
```

## 2.) Add Print Pattern to metadata
Print pattern information is also generated by manual annotation in Loupe Browser.
```{r}
# Slide 1 A1

# Add print pattern to the meta data
A1_printpattern_df <- read.csv("E:/Haylie/VHD_scPrint2-HE/S1A1_PP_ROIs_ALLPRINTS.csv")

# If there isn't an assigned print pattern add "X"
A1_printpattern_df$PrintPattern[A1_printpattern_df$PrintPattern == "" | is.na(A1_printpattern_df$PrintPattern)] <- "X"

unique(A1_printpattern_df$PrintPattern)

# head(A1_printpattern_df)

# Make sure that the barcode is the rowname of the Barcode_Anns file
rownames(A1_printpattern_df) <- A1_printpattern_df$Barcode

# get rid of the duplicate barcode
A1_printpattern_df$Barcode <- NULL

# head(A1_printpattern_df)

Slide1_A1 <- AddMetaData(Slide1_A1, metadata = A1_printpattern_df)

head(Slide1_A1)

# Confirm no missing annotations
sum(is.na(Slide1_A1@meta.data$PrintPattern))
```

```{r}
# Slide 2 D1

# Add print pattern to the meta data
D1_printpattern_df <- read.csv("E:/Haylie/VHD_scPrint2-HE/S2D1_PP_ROIs_ALLPRINTS.csv")

# If there isn't an assigned print pattern add "X"
D1_printpattern_df$PrintPattern[D1_printpattern_df$PrintPattern == "" | is.na(D1_printpattern_df$PrintPattern)] <- "X"

unique(D1_printpattern_df$PrintPattern)

# head(D1_printpattern_df)

# Make sure that the barcode is the rowname of the Barcode_Anns file
rownames(D1_printpattern_df) <- D1_printpattern_df$Barcode

# get rid of the duplicate barcode
D1_printpattern_df$Barcode <- NULL

head(D1_printpattern_df)

Slide2_D1 <- AddMetaData(Slide2_D1, metadata = D1_printpattern_df)

head(Slide2_D1)

# Confirm no missing annotations
sum(is.na(Slide2_D1@meta.data$PrintPattern))
```


## 4.) Add "Culture Condition" to metadata
Making another column in the metadata to make plotting easier. This will tell us if the cell resides in a Patterned, Random Co-Culture, or the Control mono-culture print.
```{r}
# Slide 1 A1

# Extract metadata
S1A1CC_meta <- Slide1_A1@meta.data

# Create CultureCondition column with default NA
S1A1CC_meta$CultureCondition <- "X"

# Assign based on PrintPattern values
S1A1CC_meta$CultureCondition[grepl("^Pattern_", S1A1CC_meta$PrintPattern)] <- "Pattern"

S1A1CC_meta$CultureCondition[grepl("^Random_", S1A1CC_meta$PrintPattern)] <- "Random"

S1A1CC_meta$CultureCondition[grepl("_CTRL$", S1A1CC_meta$PrintPattern)] <- "Control"

# Add the updated metadata back to the Seurat object
Slide1_A1@meta.data <- S1A1CC_meta

head(Slide1_A1)
```

```{r}
# Slide 2 D1

# Extract metadata
S2D1CC_meta <- Slide2_D1@meta.data

# Create CultureCondition column with default NA
S2D1CC_meta$CultureCondition <- "X"

# Assign based on PrintPattern values
S2D1CC_meta$CultureCondition[grepl("^Pattern_", S2D1CC_meta$PrintPattern)] <- "Pattern"

S2D1CC_meta$CultureCondition[grepl("^Random_", S2D1CC_meta$PrintPattern)] <- "Random"

S2D1CC_meta$CultureCondition[grepl("_CTRL$", S2D1CC_meta$PrintPattern)] <- "Control"

# Add the updated metadata back to the Seurat object
Slide2_D1@meta.data <- S2D1CC_meta

head(Slide2_D1)
```

## 5.) Add in "CellLine" to metadata
Making another column in the metadata. This will group the control population with the experimental population (i.e. MCF10A_CTRL and MCF10A can be plotted together. We will use culture condition to group into control vs experiment). Slide 1 doesn't haven't any controls but adding anyway for the merge. 
```{r}
# Slide 1 A1

# Extract metadata
S1A1CL_meta <- Slide1_A1@meta.data

# Create CultureCondition column with default NA
S1A1CL_meta$CellLine <- "X"

# Assign based on PrintPattern values
S1A1CL_meta$CellLine[grepl("^MCF10A", S1A1CL_meta$CellType)] <- "MCF10A"

S1A1CL_meta$CellLine[grepl("^MCF7", S1A1CL_meta$CellType)] <- "MCF7"

S1A1CL_meta$CellLine[grepl("^Fibroblast", S1A1CL_meta$CellType)] <- "Fibroblast"

# Add the updated metadata back to the Seurat object
Slide1_A1@meta.data <- S1A1CL_meta

head(Slide1_A1)
```

```{r}
# Slide 2 D1

# Extract metadata
S2D1CL_meta <- Slide2_D1@meta.data

# Create CultureCondition column with default NA
S2D1CL_meta$CellLine <- "X"

# Assign based on PrintPattern values
S2D1CL_meta$CellLine[grepl("^MCF10A", S2D1CL_meta$CellType)] <- "MCF10A"

S2D1CL_meta$CellLine[grepl("^MCF7", S2D1CL_meta$CellType)] <- "MCF7"

S2D1CL_meta$CellLine[grepl("^Fibroblast", S2D1CL_meta$CellType)] <- "Fibroblast"

# Add the updated metadata back to the Seurat object
Slide2_D1@meta.data <- S2D1CL_meta

unique(Slide2_D1@meta.data$CellLine)

unique(Slide2_D1@meta.data$CellType)

head(Slide2_D1)
```

## 6.) Add in XY coordinate information to metadata
XY coordinate information is found in the space ranger outputs -> binned outputs --> whichever size you are using (here 8 um) --> spatial --> tissuepositions.parquet
```{r}
# Slide 1 A1

# load the tissue positions file, its a parquet not a .csv
A1_parquet_path <- "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide1_A1_OUTS/outs/binned_outputs/square_008um/spatial/tissue_positions.parquet"

# Read the parquet file
A1_spatial_coords <- read_parquet(A1_parquet_path)

# need the barcode as row names so that we can align it with the Seurat file
A1_spatial_coords <- A1_spatial_coords %>%
  column_to_rownames(var = "barcode")

head(A1_spatial_coords)

Slide1_A1 <- AddMetaData(Slide1_A1, metadata = A1_spatial_coords)

head(Slide1_A1@meta.data)
```

```{r}
# Slide 2 D1

# load the tissue positions file, its a parquet not a .csv
D1_parquet_path <- "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide2_D1_OUTS/outs/binned_outputs/square_008um/spatial/tissue_positions.parquet"

# Read the parquet file
D1_spatial_coords <- read_parquet(D1_parquet_path)

# need the barcode as row names so that we can align it with the Seurat file
D1_spatial_coords <- D1_spatial_coords %>%
  column_to_rownames(var = "barcode")

head(D1_spatial_coords)

Slide2_D1 <- AddMetaData(Slide2_D1, metadata = D1_spatial_coords)

head(Slide2_D1@meta.data)
```

## 7.) Add image and create ROI crops
This uses the image that was loaded into Space Ranger! CAUTION: if you load in the high res image from the outs folder this WILL NOT WORK. The high res image is very blurry + the parquet file pixel information does not align with the image in the spatial outs folder.
```{r}
# Slide 1 A1

# Load the full-res image
image_path <- "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide1_A1_Inputs/scPrint2_Slide1_A1_HE.tif"

# Set output directory
output_dir <- "E:/Haylie/VHD_scPrint2-HE/AnalysisOuts/ALL_SAMPLES"

full_image <- image_read(image_path)

# Ensure image dimensions
image_info <- image_info(full_image)

img_width <- image_info$width

img_height <- image_info$height

# Get unique PrintPattern values excluding 'X' and NA
unique_patterns <- unique(Slide1_A1$PrintPattern)

unique_patterns <- unique_patterns[!is.na(unique_patterns) & unique_patterns != "X"]

# Create a list to store cropped images
A1_cropped_images <- list()

# Loop through each unique print pattern
for (pattern in unique_patterns) {
  subset_data <- subset(Slide1_A1, PrintPattern == pattern)

  min_row <- floor(min(subset_data$pxl_row_in_fullres, na.rm = TRUE))
  max_row <- ceiling(max(subset_data$pxl_row_in_fullres, na.rm = TRUE))
  min_col <- floor(min(subset_data$pxl_col_in_fullres, na.rm = TRUE))
  max_col <- ceiling(max(subset_data$pxl_col_in_fullres, na.rm = TRUE))

  min_row <- max(1, min_row)
  min_col <- max(1, min_col)
  max_row <- min(img_height, max_row)
  max_col <- min(img_width, max_col)

  crop_width <- max(1, max_col - min_col + 1)
  crop_height <- max(1, max_row - min_row + 1)

  if (crop_width > 0 & crop_height > 0) {
    cropped_img <- tryCatch({
      image_crop(full_image, geometry_area(
        width = crop_width,
        height = crop_height,
        x_off = min_col - 1,
        y_off = min_row - 1
      ))
    }, error = function(e) {
      warning(paste("Skipping pattern", pattern, "due to cropping error:", e$message))
      NULL
    })

    if (!is.null(cropped_img)) {
      A1_cropped_images[[pattern]] <- cropped_img
      output_file <- file.path(output_dir, paste0("Slide1A1_", pattern, ".tif"))
      image_write(cropped_img, path = output_file, format = "tiff")
      message(paste("Saved:", output_file))
    }
  } else {
    warning(paste("Skipping pattern", pattern, "due to invalid cropping dimensions."))
  }
}

# Names to know what images there are - Everything but X because this isn't segmented
unique(Slide1_A1@meta.data$PrintPattern)

# Example: Access a specific cropped image
#print(A1_cropped_images[["Pattern_1"]])
```

```{r}
# Slide 2 D1

# Load the full-res image
image_path <- "E:/Haylie/VHD_scPrint2-HE/SpaceRanger_Slide2_D1_Inputs/scPrint2_Slide2_D1_HE.tif"

# Set output directory
output_dir <- "E:/Haylie/VHD_scPrint2-HE/AnalysisOuts/ALL_SAMPLES"

full_image <- image_read(image_path)

# Ensure image dimensions
image_info <- image_info(full_image)

img_width <- image_info$width

img_height <- image_info$height

# Get unique PrintPattern values excluding 'X' and NA
unique_patterns <- unique(Slide2_D1$PrintPattern)

unique_patterns <- unique_patterns[!is.na(unique_patterns) & unique_patterns != "X"]


# Create a list to store cropped images
cropped_images <- list()

# Loop through each unique print pattern
for (pattern in unique_patterns) {
  # Subset the correct object
  subset_data <- subset(Slide2_D1, PrintPattern == pattern)
  
  # Identify pixel coordinate range
  min_row <- floor(min(subset_data$pxl_row_in_fullres, na.rm = TRUE))
  max_row <- ceiling(max(subset_data$pxl_row_in_fullres, na.rm = TRUE))
  min_col <- floor(min(subset_data$pxl_col_in_fullres, na.rm = TRUE))
  max_col <- ceiling(max(subset_data$pxl_col_in_fullres, na.rm = TRUE))
  
  # Clip coordinates to image bounds
  min_row <- max(1, min_row)
  min_col <- max(1, min_col)
  max_row <- min(img_height, max_row)
  max_col <- min(img_width, max_col)
  
  crop_width <- max(1, max_col - min_col + 1)
  crop_height <- max(1, max_row - min_row + 1)
  
  if (crop_width > 0 & crop_height > 0) {
    cropped_image <- tryCatch({
      image_crop(full_image, geometry_area(
        width = crop_width, 
        height = crop_height, 
        x_off = min_col - 1, 
        y_off = min_row - 1))
    }, error = function(e) {
      warning(paste("Skipping pattern", pattern, "due to cropping error:", e$message))
      NULL
    })
    
    if (!is.null(cropped_image)) {
      cropped_images[[pattern]] <- cropped_image
      
      # Include slide name in filename to avoid overwriting
      output_file <- file.path(output_dir, paste0("Slide2D1_", pattern, ".tif"))
      image_write(cropped_image, path = output_file, format = "tiff")
      message(paste("Saved:", output_file))
    }
  } else {
    warning(paste("Skipping pattern", pattern, "due to invalid cropping dimensions."))
  }
}

# Names to know what images there are - Everything but X because this isn't segmented
unique(Slide2_D1@meta.data$PrintPattern)

# Example: Access a specific cropped image
#print(cropped_images[["MCF7_CTRL"]])
```

## 8.) Quick Spatial Viz
```{r}
# Slide 1
Haylie_colors <- c("#deaaff", "lightgreen", "#00d7ff", "#ff69b4", "#b1a4b5", "#ffba00", "#ffff00", "#ff0000")

A1.printpattern.spatial.plot <- SpatialDimPlot(Slide1_A1, group.by = "PrintPattern", pt.size.factor = 5) + scale_fill_manual(values = Haylie_colors) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Print Pattern") + ggtitle("Selected ROIs") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))


# Delete the file if it already exists
if (file.exists("A1_PrintPatterns_spatialmap.png")) {
  file.remove("A1_PrintPatterns_spatialmap.png")}

# Export
ggsave(
  filename = "A1_PrintPatterns_spatialmap.png",
  plot = A1.printpattern.spatial.plot,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")


A1.printpattern.spatial.plot
```

```{r}
# Slide 2
Haylie_colors <- c("#ffba00","#ffff00", "#ff0000", "blue", "forestgreen", "#b1a4b5")

D1.printpattern.spatial.plot <- SpatialDimPlot(Slide2_D1, group.by = "PrintPattern", pt.size.factor = 5) + scale_fill_manual(values = Haylie_colors) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Print Pattern") + ggtitle("Selected ROIs") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

# Delete the file if it already exists
if (file.exists("D1_PrintPatterns_spatialmap.png")) {
  file.remove("D1_PrintPatterns_spatialmap.png")}

# Export
ggsave(
  filename = "D1_PrintPatterns_spatialmap.png",
  plot = D1.printpattern.spatial.plot,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

D1.printpattern.spatial.plot
```

```{r}
# Slide 1
HaylieColorsMuted <- c(
  MCF10A = "#D15B5D",
  MCF7   = "#D795D1",
  Fibroblast     = "#718F77",
  X      = "black")

A1_CellTypes_in_PPROI <- subset(Slide1_A1, subset = PrintPattern %in% c("Pattern_1", "Pattern_2", "Random_1", "Random_2"))

A1.CellType.spatial.plot <- SpatialDimPlot(A1_CellTypes_in_PPROI, group.by = "CellType", pt.size.factor = 2.5, alpha = 1, image.alpha = 0) + scale_fill_manual(values = HaylieColorsMuted, breaks = names(HaylieColorsMuted)) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Cell Type") + ggtitle("Cell Type in Print Pattern ROIs") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))


# Delete the file if it already exists
if (file.exists("A1.CellType.spatial.plot.png")) {
  file.remove("A1.CellType.spatial.plot.png")}

# Export
ggsave(
  filename = "A1.CellType.spatial.plot.png",
  plot = A1.CellType.spatial.plot,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")


A1.CellType.spatial.plot
```

```{r}
# Slide 2
HaylieColorsMutedplus <- c(
  MCF10A = "#D15B5D",
  MCF7   = "#D795D1",
  Fibroblast     = "#718F77",
  MCF10A_CTRL = "red",
  MCF7_CTRL = "hotpink",
  Fibroblast_CTRL = "darkgreen",
  X      = "black")

D1_CellTypes_in_PPROI <- subset(Slide2_D1, subset = PrintPattern %in% c("Pattern_3", "Random_3", "MCF10A_CTRL", "MCF7_CTRL", "Fibroblast_CTRL"))

D1.CellType.spatial.plot <- SpatialDimPlot(D1_CellTypes_in_PPROI, group.by = "CellType", pt.size.factor = 3.7, alpha = 1, image.alpha = 0) + scale_fill_manual(values = HaylieColorsMutedplus, breaks = names(HaylieColorsMutedplus)) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Cell Type") + ggtitle("Cell Type in Print Pattern ROIs") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))


# Delete the file if it already exists
if (file.exists("D1_CellType_spatialplot.png")) {
  file.remove("D1_CellType_spatialplot.png")}

# Export
ggsave(
  filename = "D1_CellType_spatialplot.png",
  plot = D1.CellType.spatial.plot,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")


D1.CellType.spatial.plot
```


## 9.) Merge the raw datasets (seurat objects) together
There are many issues with Seurat and V5 at this time. The following allows the two datasets to merge and fixes all the backend errors causing doublets of genes, counts, features.
```{r}
scPrint2_data <- merge(Slide1_A1, y = Slide2_D1, add.cell.ids = c("S1A1", "S2D1"), project = "scPrint2_Merged")

unique(scPrint2_data@assays)

unique(scPrint2_data@meta.data$orig.ident)
```

```{r}
# Extract counts from both layers
counts1 <- GetAssayData(scPrint2_data, layer = "counts.1")
counts2 <- GetAssayData(scPrint2_data, layer = "counts.2")

# Function to strip gene version suffixes
clean_gene_names <- function(genes) {
  str_replace(genes, "\\.[0-9]+$", "")}

rownames(counts1) <- clean_gene_names(rownames(counts1))
rownames(counts2) <- clean_gene_names(rownames(counts2))

# Function to sum duplicated gene rows
sum_duplicate_rows_sparse <- function(mat) {
  mat_t <- as(mat, "TsparseMatrix")
  unique_genes <- unique(rownames(mat))
  gene_map <- match(rownames(mat), unique_genes)
  new_i <- gene_map[mat_t@i + 1]  # 1-based for sparseMatrix
  new_j <- mat_t@j + 1

  sparseMatrix(
    i = new_i,
    j = new_j,
    x = mat_t@x,
    dims = c(length(unique_genes), ncol(mat)),
    dimnames = list(unique_genes, colnames(mat))
  )
}

# Sum duplicates
counts1 <- sum_duplicate_rows_sparse(counts1)
counts2 <- sum_duplicate_rows_sparse(counts2)

# Verify no remaining duplicates
stopifnot(length(unique(rownames(counts1))) == nrow(counts1))
stopifnot(length(unique(rownames(counts2))) == nrow(counts2))

# Merge counts
merged_counts <- cbind(counts1, counts2)

# Copy existing assay structure
new_assay <- scPrint2_data@assays$Spatial.008um
new_assay@layers <- list(counts = merged_counts)

# Rebuild LogMap for cells
cell_names <- colnames(merged_counts)
n_cells <- length(cell_names)
cells_matrix <- matrix(TRUE, nrow = n_cells, ncol = 1)
dimnames(cells_matrix) <- list(cell_names, "counts")
new_cells_logmap <- methods::new("LogMap", .Data = cells_matrix)
attr(new_cells_logmap, "dim") <- dim(cells_matrix)
attr(new_cells_logmap, "dimnames") <- dimnames(cells_matrix)

# Rebuild LogMap for features with CLEAN gene names
feature_names <- clean_gene_names(rownames(merged_counts))
n_features <- length(feature_names)
features_matrix <- matrix(TRUE, nrow = n_features, ncol = 1)
dimnames(features_matrix) <- list(feature_names, "counts")
new_features_logmap <- methods::new("LogMap", .Data = features_matrix)
attr(new_features_logmap, "dim") <- dim(features_matrix)
attr(new_features_logmap, "dimnames") <- dimnames(features_matrix)

# Assign LogMaps and finalize assay
new_assay@cells <- new_cells_logmap
new_assay@features <- new_features_logmap
new_assay@default <- 1L

# Reassign cleaned assay and set default
scPrint2_data@assays$Spatial.008um <- new_assay
DefaultAssay(scPrint2_data) <- "Spatial.008um"

# Sanity check
head(rownames(scPrint2_data))  # should be gene symbols, no .1, .2, etc.
```

```{r warning=FALSE}
# Duplicate to not overwrite
Cleaned_scPrint2_Merged <- scPrint2_data

head(Cleaned_scPrint2_Merged)

unique(Cleaned_scPrint2_Merged@meta.data$CaptureArea)
unique(Cleaned_scPrint2_Merged@meta.data$CellLine)
unique(Cleaned_scPrint2_Merged@meta.data$CultureCondition)
```


## 10.) Normalize - Log 
The raw data is saved in the counts layer. The log normalized data is saved in the data layer. Access via scPrint2_data_MCLN@assays$Spatial.008um@layers$ --> counts or data
```{r}
scPrint2_data_MCLN <- NormalizeData(Cleaned_scPrint2_Merged, layer = "counts", method = "LogNormalize")
```

```{r}
head(rownames(scPrint2_data_MCLN))
```

# XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

# Analysis

## 1.) Cell Type Annotation

### Auto-Ann 
#### -Seurat Unsupervised Clustering
https://satijalab.org/seurat/articles/visiumhd_analysis_vignette#unsupervised-clustering
```{r}
# note that data is already normalized
scPrint2_data_AutoAnn_Seurat <- scPrint2_data_MCLN

scPrint2_data_AutoAnn_Seurat <- subset(scPrint2_data_AutoAnn_Seurat, subset = PrintPattern %in% c("Pattern_1", "Pattern_2", "Pattern_3", "Random_1", "Random_2", "Random_3"))

DefaultAssay(scPrint2_data_AutoAnn_Seurat) <- "Spatial.008um"

scPrint2_data_AutoAnn_Seurat <- FindVariableFeatures(scPrint2_data_AutoAnn_Seurat)
scPrint2_data_AutoAnn_Seurat <- ScaleData(scPrint2_data_AutoAnn_Seurat)

# we select 50,0000 cells and create a new 'sketch' assay. **NOTE: I had to switch method to Uniform instead of LeverageScore because it kept timing out 
scPrint2_data_AutoAnn_Seurat <- SketchData(
  object = scPrint2_data_AutoAnn_Seurat,
  ncells = 50000,
  method = "Uniform",
  sketched.assay = "sketch")

# switch analysis to sketched cells
DefaultAssay(scPrint2_data_AutoAnn_Seurat) <- "sketch"

# perform clustering workflow
scPrint2_data_AutoAnn_Seurat <- FindVariableFeatures(scPrint2_data_AutoAnn_Seurat)

scPrint2_data_AutoAnn_Seurat <- ScaleData(scPrint2_data_AutoAnn_Seurat)

scPrint2_data_AutoAnn_Seurat <- RunPCA(scPrint2_data_AutoAnn_Seurat, assay = "sketch", reduction.name = "pca.sketch")

# elbow plot to identify dims
ElbowPlot(scPrint2_data_AutoAnn_Seurat, ndims = 100, reduction = "pca.sketch")
```

```{r}
# Set dims based on the above elbow plot. 
scPrint2_data_AutoAnn_Seurat <- FindNeighbors(scPrint2_data_AutoAnn_Seurat, assay = "sketch", reduction = "pca.sketch", dims = 1:5)

scPrint2_data_AutoAnn_Seurat <- FindClusters(scPrint2_data_AutoAnn_Seurat, cluster.name = "seurat_cluster.sketched", resolution = 0.6)

scPrint2_data_AutoAnn_Seurat <- RunUMAP(scPrint2_data_AutoAnn_Seurat, reduction = "pca.sketch", reduction.name = "umap.sketch", return.model = T, dims = 1:5)

scPrint2_data_AutoAnn_Seurat <- ProjectData(
  object = scPrint2_data_AutoAnn_Seurat,
  assay = "Spatial.008um",
  full.reduction = "full.pca.sketch",
  sketched.assay = "sketch",
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:5,
  refdata = list(seurat_cluster.projected = "seurat_cluster.sketched")
)

DefaultAssay(scPrint2_data_AutoAnn_Seurat) <- "sketch"

Idents(scPrint2_data_AutoAnn_Seurat) <- "seurat_cluster.sketched"

p1 <- DimPlot(scPrint2_data_AutoAnn_Seurat, reduction = "umap.sketch", label = F) + ggtitle("Sketched clustering (50,000 cells)") + theme(legend.position = "bottom")

# switch to full dataset
DefaultAssay(scPrint2_data_AutoAnn_Seurat) <- "Spatial.008um"

Idents(scPrint2_data_AutoAnn_Seurat) <- "seurat_cluster.projected"

p2 <- DimPlot(scPrint2_data_AutoAnn_Seurat, reduction = "full.umap.sketch", label = F) + ggtitle("Projected clustering (full dataset)") + theme(legend.position = "bottom")

p1 | p2
```


```{r}
Slide1_USC <- subset(scPrint2_data_AutoAnn_Seurat, subset = CaptureArea == "Slide1_A1")

custom_colors <- c(
  "0" = "#718F77",
  "1" = "#D15B5D",
  "2" = "#AFABAB",
  "3" = "#DD9358",
  "4" = "#D795D1",
  "5" = "#796089",
  "6" = "#6A7AA1",
  "7" = "#4D4E53")

levels_ordered <- sort(as.numeric(levels(Idents(Slide1_USC))))

Idents(Slide1_USC) <- factor(Idents(Slide1_USC), levels = levels_ordered)

slide1_UnsupervisedClustering_SpatialPlot <- SpatialDimPlot(
  Slide1_USC,
  pt.size.factor = 2.5,
  alpha = 1,
  cols = custom_colors
) +
  ggtitle("Unsupervised Clustering: Capture Area A1") +
  guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) +
  labs(fill = "Clusters") +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  )

# Delete the file if it already exists
if (file.exists("slide1_UnsupervisedClustering_SpatialPlot.png")) {
  file.remove("slide1_UnsupervisedClustering_SpatialPlot.png")}

ggsave(
  filename = "slide1_UnsupervisedClustering_SpatialPlot.png",
  plot = slide1_UnsupervisedClustering_SpatialPlot,
  width = 6,
  height = 5,
  dpi = 300,
  units = "in")

slide1_UnsupervisedClustering_SpatialPlot
```

#### -Using my controls, transfer anchors
https://satijalab.org/seurat/articles/integration_mapping or https://satijalab.org/seurat/reference/findtransferanchors
```{r}
# Split reference and query
reference_obj <- subset(scPrint2_data_MCLN, subset = PrintPattern %in% c("MCF10A_CTRL", "MCF7_CTRL", "Fibroblast_CTRL"))

query_obj <- subset(scPrint2_data_MCLN, subset = PrintPattern %in% c("Pattern_1", "Pattern_2", "Pattern_3", "Random_1", "Random_2", "Random_3"))

# Set cell type labels for reference
Idents(reference_obj) <- "CellType"

# Identify features (used log normalized data)
reference_obj <- FindVariableFeatures(reference_obj)

query_obj <- FindVariableFeatures(query_obj)

# Find transfer anchors
anchors <- FindTransferAnchors(
  reference = reference_obj,
  query     = query_obj,
  dims      = 1:5, # from elbow plot
  reference.assay = "Spatial.008um",
  query.assay     = "Spatial.008um",
  reduction = "pcaproject"
)

# Transfer labels
query_obj <- TransferData(
  anchorset = anchors,
  refdata   = Idents(reference_obj),
  dims      = 1:5,
  weight.reduction = "pca",
  query = query_obj
)

# Add predictions to metadata
query_obj$predicted_celltype <- query_obj$predicted.id
query_obj$prediction_score   <- query_obj$predicted.id.score

# Merge back with reference for full plot
annotated_obj <- merge(reference_obj, query_obj)

# Visualize results
Slide1_PredictedCellType_CusRef <- subset(annotated_obj, subset = CaptureArea == "Slide1_A1")

color_map <- c(
  "MCF10A_CTRL"     = "#D15B5D",
  "MCF7_CTRL"       = "#D795D1",
  "Fibroblast_CTRL" = "#718F77")

label_map <- c(
  "MCF10A_CTRL"     = "MCF10A",
  "MCF7_CTRL"       = "MCF7",
  "Fibroblast_CTRL" = "Fibroblast")

Slide1_CusRefPredict_SpatialPlot <- SpatialDimPlot(
  Slide1_PredictedCellType_CusRef,
  group.by = "predicted_celltype",
  pt.size.factor = 2.5,
  alpha = 1,
  image.alpha = 0,
  cols = color_map
) +
  scale_fill_manual(
    values = color_map,
    labels = label_map,
    name   = "Cell Type"
  ) +
  guides(fill = guide_legend(override.aes = list(size = 5)))

# Delete the file if it already exists
if (file.exists("Slide1_CusRefPredict_SpatialPlot.png")) {
  file.remove("Slide1_CusRefPredict_SpatialPlot.png")}

ggsave(
  filename = "Slide1_CusRefPredict_SpatialPlot.png",
  plot = Slide1_CusRefPredict_SpatialPlot,
  width = 6,
  height = 5,
  dpi = 300,
  units = "in")

Slide1_CusRefPredict_SpatialPlot
```

### Manual Annotation
Because my cells are transduced, I have ground truth data for annotation. These manual annotations were loaded in above in step 5. 

###### Pattern Annotation
```{r}
Haylie_colors4 <- c(
  MCF10A = "#FF2600",
  MCF7   = "#FF40FF",
  Fibroblast     = "#2A9518",
  X      = "black")

HaylieColorsMuted <- c(
  MCF10A = "#D15B5D",
  MCF7   = "#D795D1",
  Fibroblast     = "#718F77",
  X      = "black")

# Only plotting one of the prints here
Pat1 <- subset(scPrint2_data_MCLN, subset = PrintPattern == "Pattern_1")

Pat1_Annotation <- SpatialDimPlot(Pat1, group.by = "CellType", pt.size.factor = 9, image.alpha = 0) + scale_fill_manual(values = HaylieColorsMuted, breaks = names(HaylieColorsMuted)) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Cell Type") + ggtitle("Pattern") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

# Delete the file if it already exists
if (file.exists("Pat1_CellType_spatialmap.png")) {
  file.remove("Pat1_CellType_spatialmap.png")
}

# Set the file path and export
ggsave(
  filename = "Pat1_CellType_spatialmap.png",
  plot = Pat1_Annotation,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in",
  bg = "transparent")

Pat1_Annotation
```

```{r}
# Pattern H&E
# Make the H&E the same dimensions. Workaround because all the other plots aren't working. 

#print(A1_cropped_images[["Pattern_1"]])

# Get your cropped image
roi_image <- A1_cropped_images[["Pattern_1"]]

# Convert magick image to raster
roi_grob <- grid::rasterGrob(as.raster(roi_image), interpolate = FALSE)

# Wrap in ggplot
Pat1_HE <- ggplot() +
  annotation_custom(roi_grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) +
  theme_void()

# Delete the file if it already exists
if (file.exists("Pattern1_HE_ROI.png")) {
  file.remove("Pattern1_HE_ROI.png")
}

# Save the plot
ggsave(
  filename = "Pattern1_HE_ROI.png",
  plot = Pat1_HE,
  width = 6,
  height = 5,
  dpi = 600,
  units = "in"
)

Pat1_HE
```

##### Random Annotation
```{r}
Haylie_colors4 <- c(
  MCF10A = "#FF2600",
  MCF7   = "#FF40FF",
  Fibroblast     = "#2A9518",
  X      = "black")

HaylieColorsMuted <- c(
  MCF10A = "#D15B5D",
  MCF7   = "#D795D1",
  Fibroblast     = "#718F77",
  X      = "black")

# Pulling only one print
Ran1 <- subset(scPrint2_data_MCLN, subset = PrintPattern == "Random_1")

Ran1_Annotation <- SpatialDimPlot(Ran1, group.by = "CellType", pt.size.factor = 9, image.alpha = 0) + scale_fill_manual(values = HaylieColorsMuted, breaks = names(HaylieColorsMuted)) + theme(legend.position = "right") + guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + labs(fill = "Cell Type") + ggtitle("Random") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

# Delete the file if it already exists
if (file.exists("Ran1_CellType_spatialmap.png")) {
  file.remove("Ran1_CellType_spatialmap.png")}

# Set the file path and export
ggsave(
  filename = "Ran1_CellType_spatialmap.png",
  plot = Ran1_Annotation,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in",
  bg = "transparent")

Ran1_Annotation
```

```{r}
# Random
# Make the H&E the same dimensions. Workaround because all the other plots aren't working. 

#print(A1_cropped_images[["Random_1"]])

# Get your cropped image
roi_image <- A1_cropped_images[["Random_1"]]

# Convert magick image to raster
roi_grob <- grid::rasterGrob(as.raster(roi_image), interpolate = FALSE)

# Wrap in ggplot
Ran1_HE <- ggplot() +
  annotation_custom(roi_grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf) +
  theme_void()

# Delete the file if it already exists
if (file.exists("Random1_HE_ROI.png")) {
  file.remove("Random1_HE_ROI.png")}

# Save the plot
ggsave(
  filename = "Random1_HE_ROI.png",
  plot = Ran1_HE,
  width = 5,
  height = 6,
  dpi = 600,
  units = "in")

Ran1_HE
```

## 2.) Pop % per print
```{r}
HaylieColors <- c(
  MCF10A     = "#D15B5D",
  MCF7       = "#D795D1",
  Fibroblast = "#718F77")

patterns <- c("Pattern_1","Pattern_2","Pattern_3", "Random_1","Random_2","Random_3")

PrintPops_obj <- subset(scPrint2_data_MCLN, subset = PrintPattern %in%  c("Pattern_1","Pattern_2","Pattern_3", "Random_1","Random_2","Random_3"))

PrintPops_obj <- subset(PrintPops_obj, subset = CellType %in%  c("MCF10A","MCF7","Fibroblast"))

PrintPops <- PrintPops_obj@meta.data %>% filter(PrintPattern %in% patterns, CellType %in% c("MCF10A","MCF7","Fibroblast")) %>% mutate(PrintPattern = factor(PrintPattern, levels = patterns), CellType = factor(trimws(as.character(CellType)), levels = names(HaylieColors)))

PrintPops_BarChart <- ggplot(PrintPops, aes(x = PrintPattern, fill = CellType)) +
  geom_bar(position = "fill") +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = c(0, 0)
  ) +
  scale_fill_manual(values = HaylieColors) +
  labs(
    x = NULL,
    y = "Population Composition (% Barcodes)",
    fill = "Cell Type",
    title = "Sample Cell Type Composition"
  ) +
  theme_classic(base_size = 12) +
  theme(
    axis.text.x  = element_text(angle = 45, hjust = 1, vjust = 1),
    plot.title   = element_text(hjust = 0.5)
  )

# Delete the file if it already exists
if (file.exists("A1_PrintPatterns_spatialmap.png")) {
  file.remove("A1_PrintPatterns_spatialmap.png")}

# Export
ggsave(
  filename = "Sample_CellType_Composition.png",
  plot = PrintPops_BarChart,
  width = 5, 
  height = 5,  
  dpi = 300,
  units = "in")

PrintPops_BarChart
```



## 3.) DEGs. Cell type DEGs Using Control Populations
```{r}
# Using the control populations from slide 2
Slide2_Controls <- subset(scPrint2_data_MCLN, subset = CellType %in% c("MCF7_CTRL", "MCF10A_CTRL", "Fibroblast_CTRL"))

unique(Slide2_Controls@meta.data$CellType)
```

### MCF10A v MCF7
```{r}
Idents(Slide2_Controls) <- "CellType"

CTRLS_MCF10AvMCF7 <- subset(Slide2_Controls, subset = CellType %in% c("MCF10A_CTRL", "MCF7_CTRL"))

# Pairwise comparison. MCF7 vs MCF10A
markers_MCF10AvMCF7 <- FindMarkers(CTRLS_MCF10AvMCF7, ident.1 = "MCF10A_CTRL", ident.2 = "MCF7_CTRL")

# Make list of top 20 genes by adjusted p-value
MCF10AvMCF7_topgenes <- head(rownames(markers_MCF10AvMCF7[order(markers_MCF10AvMCF7$p_val_adj), ]), 20)

MCF10AvMCF7_DotPlot <- DotPlot(CTRLS_MCF10AvMCF7, features = MCF10AvMCF7_topgenes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") + ggtitle("MCF10A vs MCF7") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))


# Delete the file if it already exists
if (file.exists("MCF10AvMCF7_DotPlot.png")) {
  file.remove("MCF10AvMCF7_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "MCF10AvMCF7_DotPlot.png",
  plot = MCF10AvMCF7_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

MCF10AvMCF7_DotPlot
```

#### MCF10A Enriched
```{r}
# MCF10A enriched
top_mcf10a_genes <- head(rownames(markers_MCF10AvMCF7[order(-markers_MCF10AvMCF7$avg_log2FC), ]), 20)

MCF10AEnriched_MCF10AvMCF7_DotPlot <- DotPlot(CTRLS_MCF10AvMCF7, features = top_mcf10a_genes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") + ggtitle("MCF10A Enriched") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))

# Delete the file if it already exists
if (file.exists("MCF10AEnriched_MCF10AvMCF7_DotPlot.png")) {
  file.remove("MCF10AEnriched_MCF10AvMCF7_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "MCF10AEnriched_MCF10AvMCF7_DotPlot.png",
  plot = MCF10AEnriched_MCF10AvMCF7_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

MCF10AEnriched_MCF10AvMCF7_DotPlot
```

#### MCF7 Enriched
```{r}
CTRLS_MCF7vMCF10A <- subset(Slide2_Controls, subset = CellType %in% c("MCF7_CTRL", "MCF10A_CTRL"))

# Differential expression: MCF7 vs MCF10A
markers_MCF7vMCF10A <- FindMarkers(CTRLS_MCF7vMCF10A, ident.1 = "MCF7_CTRL", ident.2 = "MCF10A_CTRL")

# MCF7 enriched
top_mcf7_genes <- head(rownames(markers_MCF7vMCF10A[order(-markers_MCF7vMCF10A$avg_log2FC), ]), 20)

MCF7Enriched_MCF10AvMCF7_DotPlot <- DotPlot(CTRLS_MCF7vMCF10A, features = top_mcf7_genes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") +
  ggtitle("MCF7 Enriched") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))

# Delete the file if it already exists
if (file.exists("MCF7Enriched_MCF10AvMCF7_DotPlot.png")) {
  file.remove("MCF7Enriched_MCF10AvMCF7_DotPlot.png")
}

# Save the Plot
ggsave(
  filename = "MCF7Enriched_MCF10AvMCF7_DotPlot.png",
  plot = MCF7Enriched_MCF10AvMCF7_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in"
)

MCF7Enriched_MCF10AvMCF7_DotPlot
```



### FB v MCF7
```{r}
Idents(Slide2_Controls) <- "CellType"

CTRLS_FBvMCF7 <- subset(Slide2_Controls, subset = CellType %in% c("Fibroblast_CTRL", "MCF7_CTRL"))

# Pairwise comparison. MCF7 vs MCF10A
markers_FBAvMCF7 <- FindMarkers(CTRLS_FBvMCF7, ident.1 = "Fibroblast_CTRL", ident.2 = "MCF7_CTRL")

# Make list of top 20 genes by adjusted p-value
FBvMCF7_topgenes <- head(rownames(markers_FBAvMCF7[order(markers_FBAvMCF7$p_val_adj), ]), 20)

FBvMCF7_DotPlot <- DotPlot(CTRLS_FBvMCF7, features = FBvMCF7_topgenes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  + ggtitle("FB vs MCF7") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))


# Delete the file if it already exists
if (file.exists("FBvMCF7_DotPlot.png")) {
  file.remove("FBvMCF7_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "FBvMCF7_DotPlot.png",
  plot = FBvMCF7_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

FBvMCF7_DotPlot
```

#### FB Enriched
```{r}
# FB Enriched
markers_FBvMCF7 <- FindMarkers(CTRLS_FBvMCF7, ident.1 = "Fibroblast_CTRL", ident.2 = "MCF7_CTRL")

# Get top 20 genes with highest positive log2 fold change (FB enriched)
top_FB_genes <- head(rownames(markers_FBvMCF7[order(-markers_FBvMCF7$avg_log2FC), ]), 20)

# DotPlot of top FB enriched genes
FBEnriched_FBvMCF7_DotPlot <- DotPlot(CTRLS_FBvMCF7, features = top_FB_genes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") + ggtitle("Fibroblast Enriched vs MCF7") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))

# Delete existing file if it exists
if (file.exists("FBEnriched_FBvMCF7_DotPlot.png")) {
  file.remove("FBEnriched_FBvMCF7_DotPlot.png")}

# Save the plot
ggsave(
  filename = "FBEnriched_FBvMCF7_DotPlot.png",
  plot = FBEnriched_FBvMCF7_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

FBEnriched_FBvMCF7_DotPlot
```


### FB v MCF10A
```{r}
Idents(Slide2_Controls) <- "CellType"

CTRLS_FBvMCF10A <- subset(Slide2_Controls, subset = CellType %in% c("Fibroblast_CTRL", "MCF10A_CTRL"))

# Pairwise comparison. MCF7 vs MCF10A
markers_FBAvMCF10A <- FindMarkers(CTRLS_FBvMCF10A, ident.1 = "Fibroblast_CTRL", ident.2 = "MCF10A_CTRL")

# Make list of top 20 genes by adjusted p-value
FBvMCF10A_topgenes <- head(rownames(markers_FBAvMCF10A[order(markers_FBAvMCF10A$p_val_adj), ]), 20)

FBvMCF10A_DotPlot <- DotPlot(CTRLS_FBvMCF10A, features = FBvMCF10A_topgenes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  + ggtitle("FB vs MCF10A") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))


# Delete the file if it already exists
if (file.exists("FBvMCF10A_DotPlot.png")) {
  file.remove("FBvMCF10A_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "FBvMCF10A_DotPlot.png",
  plot = FBvMCF10A_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

FBvMCF10A_DotPlot
```

#### FB Enriched
```{r}
# Subset to just Fibroblast and MCF10A
CTRLS_FBvMCF10A <- subset(Slide2_Controls, subset = CellType %in% c("Fibroblast_CTRL", "MCF10A_CTRL"))

# Differential expression: Fibroblast vs MCF10A
markers_FBvMCF10A <- FindMarkers(CTRLS_FBvMCF10A, ident.1 = "Fibroblast_CTRL", ident.2 = "MCF10A_CTRL")

# Fibroblast enriched
top_fb_genes <- head(rownames(markers_FBvMCF10A[order(-markers_FBvMCF10A$avg_log2FC), ]), 20)

FBEnriched_MCF10AvFB_DotPlot <- DotPlot(CTRLS_FBvMCF10A, features = top_fb_genes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") + ggtitle("Fibroblast Enriched vs MCF10A") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))

# Delete the file if it already exists
if (file.exists("FBEnriched_MCF10AvFB_DotPlot.png")) {
  file.remove("FBEnriched_MCF10AvFB_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "FBEnriched_MCF10AvFB_DotPlot.png",
  plot = FBEnriched_MCF10AvFB_DotPlot,
  width = 8, 
  height = 4,  
  dpi = 300,
  units = "in")

FBEnriched_MCF10AvFB_DotPlot
```



### All vs All
```{r}
Idents(Slide2_Controls) <- "CellType"

# Global DE across all control populations
markers_AllCTRL <- FindAllMarkers(Slide2_Controls)

# Make list of top 20 genes by adjusted p-value
AllCTRL_topgenes <- head(rownames(markers_AllCTRL[order(markers_AllCTRL$p_val_adj), ]), 20)

AllCTRLvsALLCTRL <- DotPlot(Slide2_Controls, features = AllCTRL_topgenes) + scale_color_gradient2(low="dodgerblue",mid = "white",high = "firebrick1") + ggtitle("MCF10A vs MCF7 vs FB") + theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.title = element_text(hjust = 0.5))

# Delete the file if it already exists
if (file.exists("AllCTRLvsALLCTRL_DotPlot.png")) {
  file.remove("AllCTRLvsALLCTRL_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "AllCTRLvsALLCTRL_DotPlot.png",
  plot = AllCTRLvsALLCTRL,
  width = 8, 
  height = 5,  
  dpi = 300,
  units = "in")

AllCTRLvsALLCTRL
```

### Cleaned Final - Supplement fig
```{r}
Slide2_Controls <- SetIdent(Slide2_Controls, value = factor(Idents(Slide2_Controls),
                                                          levels = c("MCF10A_CTRL", "MCF7_CTRL", "Fibroblast_CTRL")))

SelectGenes_AllCTRLvAllCTRL_DotPlot <- DotPlot(
  Slide2_Controls,
  features = rev(c(
    "S100A2","KRT5","KRT17",
    "TFF1","AGR2","KRT19",
    "VIM","COL1A1","COL1A2"
  )),
  dot.scale = 20 
) +
  coord_flip() +
  scale_color_gradient2(
    low  = "dodgerblue",
    mid  = "white",
    high = "firebrick1"
  ) +
  ggtitle("MCF10A vs MCF7 vs FB") +
  guides(
    color = guide_colourbar(
      title = "Average\nExpression",
      title.theme = element_text(size = 12),
      label.theme = element_text(size = 10)
    ),
    size = guide_legend(
      title = "Percent\nExpressed",
      title.theme = element_text(size = 12),
      label.theme = element_text(size = 10)
    )
  ) +
  theme(
    axis.text.x   = element_text(angle = 45, hjust = 1, size = 10),
    plot.title    = element_text(hjust = 0.5),
    legend.key.height = unit(0.35, "cm"),
    legend.key.width  = unit(0.35, "cm")
  )

# Delete the file if it already exists
if (file.exists("SelectGenes_AllCTRLvAllCTRL_DotPlot.png")) {
  file.remove("SelectGenes_AllCTRLvAllCTRL_DotPlot.png")}

# Save the Plot
ggsave(
  filename = "SelectGenes_AllCTRLvAllCTRL_DotPlot.png",
  plot = SelectGenes_AllCTRLvAllCTRL_DotPlot,
  width = 4.5, 
  height = 8,  
  dpi = 300,
  units = "in")

SelectGenes_AllCTRLvAllCTRL_DotPlot
```


#### Global overview - supplement fig
```{r}
# Union of all the pairwise DEG plots above, ordered by highest average expression. Top 20 shown in heatmap form

Slide2_Controls <- subset(
  scPrint2_data_MCLN,
  subset = CellType %in% c("MCF10A_CTRL", "MCF7_CTRL", "Fibroblast_CTRL"))

Slide2_Controls$CellType <- factor(
  Slide2_Controls$CellType,
  levels = c("MCF10A_CTRL", "MCF7_CTRL", "Fibroblast_CTRL"))

Slide2_Controls <- SetIdent(Slide2_Controls, value = "CellType")

DefaultAssay(Slide2_Controls) <- "Spatial.008um"

# Gene list 
gene_list <- c(
  "S100A2","TGFBI","KRT5","KRT17","KRT7","HSBP1","KRT8","KRT6A","PSMD6","PERP",
  "XBP1","TFF1","EEF1A2","SFN","GSTP1","CCND1","CD24","GATA3","LY6E","F3",
  "DSG3","LIP6","CLCA2","DSC3","LAMC2","COL17A1","EPGN","KRT15","TP63",
  "TRIM29","KRT16","SERPINB5","TUBA4A","DSC2","CSTA","CBFA2T3","GFRA1",
  "PREX1","CACNA1H","CDT1","KRT19","TBX2","GINS2","SPDEF","FBP1","BMP7",
  "IFI6","HIST1H1D","AGR2","C3orf14","FAM174B","SPTSSB","PARD6B","CACNG4",
  "VIM","COL1A1","SERPINE1","TIMP1","COL1A2","LGLS11","MT2A","S100A6",
  "COL6A3","TPM2","SPARC","SPINT2","SLC7A5","STARD10","CSPG4","PTx3",
  "P3H1","SERPINE2","ADAMTS1","CDH6","WNT5A","ABLIM3","EMILIN1","PRDM8",
  "PDGFRA","C1S","VCAN","SERPINB2","DDR2","LAMB1","ATP284","FBLN5",
  "BDKRB1","HSPB1","LGALS1","TNFRSF11B","RGS4","CD248","EDIL3","DAB2",
  "ELN","NID2","RAB3B","KCNMA1","LRRC17","NR2F1","SMARCA1","FLNC",
  "COL5A1","CCL2","HSPB6","ANXA5")


# Average expression per CellType 
avg_expr_list <- AverageExpression(
  Slide2_Controls,
  features = gene_list,
  group.by = "CellType",
  assay    = "Spatial.008um",
  slot     = "data"
)
avg_expr <- as.matrix(avg_expr_list[[1]])   # genes x cell types

avg_expr[is.na(avg_expr)] <- 0

# Sanity check
print(colnames(avg_expr))
# You should see: "MCF10A-CTRL" "MCF7-CTRL" "Fibroblast-CTRL"

# For each gene, which column (cell type) has highest avg expression
max_idx <- max.col(avg_expr, ties.method = "first")
best_ct <- colnames(avg_expr)[max_idx]

order_df <- data.frame(
  gene    = rownames(avg_expr),
  best_ct = best_ct,
  stringsAsFactors = FALSE)

# Use the column names for block order 
ct_order_expr <- colnames(avg_expr)  

# Display top 20 genes - adjust as needed
top_per_ct    <- 20

gene_order <- character(0)

for (ct in ct_order_expr) {
  df_ct <- order_df[order_df$best_ct == ct, , drop = FALSE]
  if (!nrow(df_ct)) next

  # expression of those genes in that CT
  idx <- match(df_ct$gene, rownames(avg_expr))
  idx <- idx[!is.na(idx)]
  if (!length(idx)) next

  strength <- avg_expr[idx, ct]
  df_ct$strength <- strength

  # reorder df_ct to keep same gene order as strength computation
  df_ct$gene <- rownames(avg_expr)[idx]
  df_ct <- df_ct[order(-df_ct$strength), , drop = FALSE]

  df_ct <- head(df_ct, top_per_ct)
  gene_order <- c(gene_order, df_ct$gene)
}

features_heat <- unique(gene_order)
cat("Genes going into heatmap:", length(features_heat), "\n")

Slide2_Controls <- ScaleData(
  Slide2_Controls,
  assay    = "Spatial.008um",
  features = features_heat,
  verbose  = FALSE)

Idents(Slide2_Controls) <- Slide2_Controls$CellType

group_cols <- c(
  "MCF10A_CTRL"     = "#D15B5D",
  "MCF7_CTRL"       = "#D795D1",
  "Fibroblast_CTRL" = "#718F77")

# Heatmap
Supplement_Summary_Heatmap <- DoHeatmap(
  Slide2_Controls,
  assay        = "Spatial.008um",
  features     = features_heat,
  group.by     = "CellType",
  group.colors = group_cols,
  disp.min     = -2,
  disp.max     = 2,
  size         = 3,
  label        = FALSE
) +
  scale_fill_gradientn(
    colors = c("black", "magenta4", "yellow"),
    name   = "Scaled expression"
  ) +
  ggtitle("Top 20 DEGs per control cell type") +
  theme(
    plot.title   = element_text(hjust = 0.5, face = "bold"),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y  = element_text(size = 6)
  )

if (file.exists("Supplement_Summary_Heatmap.png")) {
  file.remove("Supplement_Summary_Heatmap.png")
}

ggsave(
  filename = "Supplement_Summary_Heatmap.png",
  plot     = Supplement_Summary_Heatmap,
  width    = 10,
  height   = 6,
  dpi      = 300,
  units    = "in"
)

Supplement_Summary_Heatmap
```



## 4.) Gene Heat Maps
```{r}
# Subsets used:

Pat1 <- subset(scPrint2_data_MCLN, subset = PrintPattern == "Pattern_1")

Ran1 <- subset(scPrint2_data_MCLN, subset = PrintPattern == "Random_1")
```


### MCF10A
#### S100A2 - Pat
```{r}
# Determine max for the plotting
# Get max from each object
max_pat1_S100A2 <- max(FetchData(Pat1, vars = "S100A2"), na.rm = TRUE)
max_ran1_S100A2 <- max(FetchData(Ran1, vars = "S100A2"), na.rm = TRUE)

# Get the larger of the two
max_S100A2 <- max(max_pat1_S100A2, max_ran1_S100A2)

max_S100A2
```

```{r}
#S100A2 - Pattern
Pat1_MCF10A_s100A2_HeatMap <- SpatialFeaturePlot(Pat1, features = "S100A2", alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_S100A2)) + theme(legend.position = "bottom") + ggtitle("S100A2, Pattern Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Pat1_MCF10A_s100A2_HeatMap.png")) {
  file.remove("Pat1_MCF10A_s100A2_HeatMap.png")
}

# Set the file path and export
ggsave(
  filename = "Pat1_MCF10A_s100A2_HeatMap.png",
  plot = Pat1_MCF10A_s100A2_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Pat1_MCF10A_s100A2_HeatMap
```

#### S100A2 - Ran
```{r}
#S100A2 - Random
Ran1_MCF10A_S100A2_HeatMap <- SpatialFeaturePlot(Ran1, features = "S100A2",  alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_S100A2)) + theme(legend.position = "right") + ggtitle("S100A2, Random Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Ran1_MCF10A_S100A2_HeatMap.png")) {
  file.remove("Ran1_MCF10A_S100A2_HeatMap.png")
}

# Set the file path and export
ggsave(
  filename = "Ran1_MCF10A_S100A2_HeatMap.png",
  plot = Ran1_MCF10A_S100A2_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Ran1_MCF10A_S100A2_HeatMap
```





### MCF7
#### TFF1 - Pat
```{r}
# Determine max for the plotting
# Get max from each object
max_pat1_TFF1 <- max(FetchData(Pat1, vars = "TFF1"), na.rm = TRUE)
max_Ran1_TFF1 <- max(FetchData(Ran1, vars = "TFF1"), na.rm = TRUE)

# Get the larger of the two
max_TFF1 <- max(max_pat1_TFF1, max_Ran1_TFF1)

max_TFF1
```

```{r}
# TFF1 - Pattern
Pat1_MCF7_TFF1_HeatMap <- SpatialFeaturePlot(Pat1, features = "TFF1", alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_TFF1)) + theme(legend.position = "bottom") + ggtitle("TFF1, Pattern Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Pat1_MCF7_TFF1_HeatMap.png")) {
  file.remove("Pat1_MCF7_TFF1_HeatMap.png")}

# Set the file path and export
ggsave(
  filename = "Pat1_MCF7_TFF1_HeatMap.png",
  plot = Pat1_MCF7_TFF1_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Pat1_MCF7_TFF1_HeatMap
```



#### TFF1 - Ran
```{r}
# TFF1 - Random
Ran1_MCF7_TFF1_HeatMap <- SpatialFeaturePlot(Ran1, features = "TFF1",  alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_TFF1)) + theme(legend.position = "right") + ggtitle("TFF1, Random Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Ran1_MCF7_TFF1_HeatMap.png")) {
  file.remove("Ran1_MCF7_TFF1_HeatMap.png")
}

# Set the file path and export
ggsave(
  filename = "Ran1_MCF7_TFF1_HeatMap.png",
  plot = Ran1_MCF7_TFF1_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Ran1_MCF7_TFF1_HeatMap
```


### Fibroblast
#### VIM - Pat
```{r}
# Determine max for the plotting
# Get max from each object
max_pat1_VIM <- max(FetchData(Pat1, vars = "VIM"), na.rm = TRUE)
max_Ran1_VIM <- max(FetchData(Ran1, vars = "VIM"), na.rm = TRUE)

# Get the larger of the two
max_VIM <- max(max_pat1_VIM, max_Ran1_VIM)

max_VIM
```

```{r}
# VIM - Pattern
Pat1_FB_VIM_HeatMap <- SpatialFeaturePlot(Pat1, features = "VIM", alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_VIM)) + theme(legend.position = "bottom") + ggtitle("VIM, Pattern Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Pat1_FB_VIM_HeatMap.png")) {
  file.remove("Pat1_FB_VIM_HeatMap.png")}

# Set the file path and export
ggsave(
  filename = "Pat1_FB_VIM_HeatMap.png",
  plot = Pat1_FB_VIM_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Pat1_FB_VIM_HeatMap
```

#### VIM - Ran
```{r}
# VIM - Random
Ran1_FB_VIM_HeatMap <- SpatialFeaturePlot(Ran1, features = "VIM",  alpha = c(1, 1), image.alpha = 0, pt.size.factor = 9) + scale_fill_gradientn(colors = c("black", "#0106F5", "#00FDFF", "#75FB4E", "#FBFF54", "#EA3524"), limits = c(0,max_VIM)) + theme(legend.position = "right") + ggtitle("VIM, Random Print") + theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))

##### NOTE: I set the scale limits so that my samples have the same scale #####

# Delete the file if it already exists
if (file.exists("Ran1_FB_VIM_HeatMap.png")) {
  file.remove("Ran1_FB_VIM_HeatMap.png")
}

# Set the file path and export
ggsave(
  filename = "Ran1_FB_VIM_HeatMap.png",
  plot = Ran1_FB_VIM_HeatMap,
  width = 6, 
  height = 5,  
  dpi = 300,
  units = "in")

Ran1_FB_VIM_HeatMap
```


## 5.) GO BP Pat v Ran
Gene ontology biological processes enrichment of all barcodes in pat v all barcodes in ran
```{r}
# Subset only the annotated cells within the print patterns
PatRan_n3_scPrint2_data_MCLN <- subset(
  scPrint2_data_MCLN,
  subset = CultureCondition %in% c("Pattern","Random") &
           CellLine %in% c("MCF10A","MCF7","Fibroblast"))

# Differential expression: Pattern vs Random across all barcodes
Idents(PatRan_n3_scPrint2_data_MCLN) <- "CultureCondition"

de_allPrints <- FindMarkers(
  object          = PatRan_n3_scPrint2_data_MCLN,
  ident.1         = "Pattern",
  ident.2         = "Random",
  logfc.threshold = 0,
  min.pct         = 0,
  test.use        = "wilcox")

# Over representation analysis - selects genes higher in Pattern than Random
upP <- rownames(de_allPrints)[de_allPrints$avg_log2FC >  0 & de_allPrints$p_val_adj < 0.05]

# convert gene symbols into Entrez IDs
entP <- bitr(upP, fromType="SYMBOL", toType="ENTREZID", OrgDb=org.Hs.eg.db)$ENTREZID

# run GO BP for Pattern
egoP <- enrichGO(
  gene          = entP,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.1,
  readable      = TRUE)

# Helper function that uppercases only the 1st letter, leaves the rest untouched, so when we plot the GO's they look nice
cap1 <- function(x) {
  first <- toupper(substring(x, 1, 1))
  rest  <- substring(x, 2)
  paste0(first, rest)
}

# Formats the GO terms so the first letter is capitalized. Simpy aesthetics for plotting
egoP@result$Description <- cap1(egoP@result$Description)

# Select top 12 GO terms by adjusted p-value for Pattern & convert to -log10(padj) for bar lengths
dfP <- egoP@result %>%
  arrange(p.adjust) %>%
  slice_head(n = 12) %>%
  transmute(
    Term    = Description,
    logAdjP = -log10(p.adjust),  # positive, bars to the right
    Group   = "Pattern")


# Repeat process for Random
upR <- rownames(de_allPrints)[de_allPrints$avg_log2FC < 0 & de_allPrints$p_val_adj < 0.05]

entR <- bitr(upR, fromType="SYMBOL", toType="ENTREZID", OrgDb=org.Hs.eg.db)$ENTREZID

egoR    <- enrichGO(
  gene          = entR,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.1,
  readable      = TRUE)

# Formats the GO terms so the first letter is capitalized. Simpy aesthetics for plotting
egoR@result$Description <- cap1(egoR@result$Description)

# Select top 12 GO terms by adjusted p-value for Random & convert to -log10(padj) for bar lengths
dfR <- egoR@result %>%
  arrange(p.adjust) %>%
  slice_head(n = 12) %>%
  transmute(
    Term    = Description,
    logAdjP =  log10(p.adjust),
    Group   = "Random")


# combine and build Term factor so Random terms sit at bottom, Pattern at top, and the first letter of each row is capitalized
df <- bind_rows(dfR, dfP)

# factor levels: first all Random terms in ascending p.adjust order (bottom),
term_levels <- c(rev(dfR$Term), rev(dfP$Term))

# then all Pattern terms in descending significance at top:
df$Term <- factor(df$Term, levels = term_levels)


# Plot with all the formatting adjustments included
GOBP_PatRan_BarPlot <- ggplot(df, aes(x = logAdjP, y = Term, fill = Group)) +
  # bars
  geom_col(width = 0.7) +
  # vertical zero line
  geom_vline(xintercept = 0, color = "black", size = 0.8) +
  geom_hline(yintercept = 0, colour = "black", size = 0.8) +
  # Pattern terms to the right of zero
   geom_text(
    data    = subset(df, Group == "Pattern"),
    aes(x    = 0, label = Term),
    hjust   = 1,
    nudge_x = -0.2,   
    nudge_y  = 0.05,
    size    = 3
  ) +
  # Random terms to the left of zero
  geom_text(
    data    = subset(df, Group == "Random"),
    aes(x    = 0, label = Term),
    hjust   = 0,  
    nudge_x = 0.2,     
    nudge_y  = 0.05,
    size    = 3) +
  # colors
  scale_fill_manual(
    values = c(Pattern = "#796089", Random = "#DD9358"),
    guide  = guide_legend(reverse = FALSE)) +
  # mirrored x-axis
  scale_x_continuous(
    limits = c(-25, 35),
    breaks = c(-25, -20, -15, -10, -5, 0, 5, 10, 15),
    expand = c(0,0)) +
  # title + theme tweaks
  labs(
    title = "GO-BP Enrichment: Pattern vs Random",
    x     = expression(-log[10]~(adjusted~P~value)), 
    y     = NULL, 
    size = 1,
    fill  = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    axis.title.x = element_text(size = 10),
    axis.ticks.x      = element_line(color = "black", size = 0.8),
    axis.text.y       = element_blank(),
    panel.grid.major  = element_blank(),
    panel.grid.minor  = element_blank(),
    axis.text.x       = element_text(size = 10, color = "black"),
    axis.line.x       = element_line(color = "black", size = 0.8),
    legend.position   = "right",
    plot.title        = element_text(face = "bold", size = 14, color = "black"))

# Delete the file if it already exists
if (file.exists("GOBP_PatRan_BarPlot.png")) {file.remove("GOBP_PatRan_BarPlot.png")}

# Save
ggsave(
  filename = "GOBP_PatRan_BarPlot.png",
  plot = GOBP_PatRan_BarPlot,
  width = 9, 
  height = 5.5,  
  dpi = 300,
  units = "in")

GOBP_PatRan_BarPlot
```

## 6.) ssGSEA Cancer Pathway Analysis
```{r}
# There are issues with EnrichIt() package, so the following has some patches to make it work. For example, it insists the assay is in the RNA slot, but VHD data is saved as "Spatial.008um" in the seurat object. So we will duplicate our seurat object to not overwrite the original and amend the new one (scPrint2_merged_ssGSEA) to work with the Escape EnrichIt ssGSEA analysis.

# Duplicate the raw data, pre-log normalization, but after the capture area merges
scPrint2_merged_ssGSEA <- scPrint2_data

# Copy the *raw* Spatial.008um data into a new RNA assay
scPrint2_merged_ssGSEA[["RNA"]] <- CreateAssayObject(
  counts = GetAssayData(scPrint2_merged_ssGSEA, assay = "Spatial.008um", layer = "counts"))

# Make RNA the default
DefaultAssay(scPrint2_merged_ssGSEA) <- "RNA"

# Log Normalize
scPrint2_merged_ssGSEA <- NormalizeData(scPrint2_merged_ssGSEA, assay="RNA", normalization.method="LogNormalize")

# Sanity check  now your RNA assay has both a counts slot and a data slot:
Assays(scPrint2_merged_ssGSEA)
#  Spatial.008um and RNA 

# Raw is saved in the Counts slot:
#head(GetAssayData(scPrint2_merged_ssGSEA, "RNA", slot="counts"))   # raw counts

# Log normalized is saved in the Data slot: 
#head(GetAssayData(scPrint2_merged_ssGSEA, "RNA", slot="data"))

# Subset data so ssGSEA doesn't take so long
scPrint2_merged_ssGSEA <- subset(scPrint2_merged_ssGSEA, subset = PrintPattern %in% c("Pattern_1", "Pattern_2", "Pattern_3", "Random_1", "Random_2", "Random_3", "MCF10A_CTRL","MCF7_CTRL", "Fibroblast_CTRL" ))

# Grab the gene names from the *data* slot (thats where normalized expression lives)
expr_genes <- rownames(GetAssayData(scPrint2_merged_ssGSEA, assay="RNA", slot="data"))

# Build the Hallmark lists from theMSigDB Hallmark gene sets
all_hallmarks <- msigdbr(
    species  = "Homo sapiens",
    collection = "H"
) %>% 
  dplyr::select(gs_name, gene_symbol) %>% 
  split(.$gs_name) %>% 
  map(~ unique(.x$gene_symbol))

# These are my pathways of interest. Going to filter to only look at these to minimize load. ssGSEA is very heavy and slow
cancer_hallmarks <- c(
  # Sustaining Proliferative Signaling
  "HALLMARK_E2F_TARGETS",
  "HALLMARK_G2M_CHECKPOINT",
  "HALLMARK_MYC_TARGETS_V1",
  "HALLMARK_MYC_TARGETS_V2",

  # Evading Growth Suppressors
  "HALLMARK_P53_PATHWAY",
  "HALLMARK_TGF_BETA_SIGNALING",

  # Resisting Cell Death
  "HALLMARK_APOPTOSIS",
  "HALLMARK_UNFOLDED_PROTEIN_RESPONSE",

  # Genome Instability & Mutation
  "HALLMARK_DNA_REPAIR",
  
  # Activating Invasion & Metastasis
  "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION",
  "HALLMARK_APICAL_JUNCTION",

  # Deregulating Cellular Metabolism
  "HALLMARK_OXIDATIVE_PHOSPHORYLATION",
  "HALLMARK_GLYCOLYSIS",

  # Avoiding Immune Destruction 
  "HALLMARK_INTERFERON_GAMMA_RESPONSE",
  "HALLMARK_COMPLEMENT",
  "HALLMARK_INFLAMMATORY_RESPONSE",

  # Tumor-Promoting Inflammation
  "HALLMARK_TNFA_SIGNALING_VIA_NFKB",
  "HALLMARK_IL6_JAK_STAT3_SIGNALING",
  
  # Inducing Angiogenesis
  "HALLMARK_ANGIOGENESIS")

# Filter out all the msigdbr pathways expect pathways of interest
gene.sets      <- all_hallmarks[cancer_hallmarks]

# This filters any pathways that consist of less than 10 genes
filtered_sets  <- gene.sets %>% 
  map(~ intersect(.x, expr_genes)) %>% 
  keep(~ length(.x) >= 10)

# Check how many pathways survived (should be all 19)
length(filtered_sets)


############################
# FYI THIS STEP WILL TAKE A LONG TIME TO RUN

# Now run ssGSEA (single spot gene set enrichment analysis)
scPrint2_merged_ssGSEA <- runEscape(
  input.data     = scPrint2_merged_ssGSEA,
  gene.sets      = filtered_sets,
  method         = "ssGSEA",
  groups         = 1000,
  min.size       = 10,
  normalize      = FALSE,
  make.positive  = FALSE,
  new.assay.name = "ssGSEA")
############################


# Verify scGSEA has been added to the assays
Assays(scPrint2_merged_ssGSEA)

# Switch assay to ssGSEA
DefaultAssay(scPrint2_merged_ssGSEA) <- "ssGSEA"

# Z-score each pathway (feature) across all spots
scPrint2_merged_ssGSEA <- ScaleData(
  object   = scPrint2_merged_ssGSEA,
  assay    = "ssGSEA",
  features = rownames(scPrint2_merged_ssGSEA[["ssGSEA"]]),  
  verbose  = TRUE)

# Save this as a new assay for easy access
scaled_mat <- GetAssayData(
  scPrint2_merged_ssGSEA,
  assay = "ssGSEA",
  layer  = "scale.data") 

scPrint2_merged_ssGSEA[["ssGSEA_z"]] <- CreateAssayObject(data = scaled_mat)
```

Now the scaled assay data lives in assay = "ssGSEA_z

Specify slot = "scale.data" when plotting to access. Examples: 

VlnPlot(
  scPrint2_merged_ssGSEA,
  features = "HALLMARK_APOPTOSIS",
  assay    = "ssGSEA_z",
  slot     = "data",  
  group.by = "PrintPattern")

SpatialFeaturePlot(
  scPrint2_merged_ssGSEA,
  features = "HALLMARK_APOPTOSIS",
  assay    = "scGSEA_z",
  slot     = "data",
  image.alpha = 0)


## HeatMap Cancer Pathways
```{r}
ssGSEA_PatRanxCell <- subset(scPrint2_merged_ssGSEA, subset = PrintPattern %in% c("Pattern_1", "Pattern_2", "Pattern_3", "Random_1", "Random_2", "Random_3"))

# Set to use the correct assay
DefaultAssay(ssGSEA_PatRanxCell) <- "ssGSEA_z"

# Extract the ssGSEA score matrix 
ssgsea_matrix_z <- GetAssayData(ssGSEA_PatRanxCell, slot = "data")

# # Sanity check to make sure it's pulling the right values. Z scores will be small. Raw ssGSEA will be huge
# min_val <- min(ssgsea_matrix_z, na.rm = TRUE)
# max_val <- max(ssgsea_matrix_z, na.rm = TRUE)
# cat("Min ssGSEA score:", min_val, "\n")
# cat("Max ssGSEA score:", max_val, "\n")
```


```{r}
# MCF10A

# Set to use the correct assay
DefaultAssay(ssGSEA_PatRanxCell) <- "ssGSEA_z"

# Subset MCF10A
MCF10A_ssGSEA <- subset(ssGSEA_PatRanxCell, subset = CellLine == "MCF10A")

# Extract ssGSEA_z matrix
MCF10A_ssgsea_mat_z <- GetAssayData(MCF10A_ssGSEA, slot = "data")

# Grab metadata for plotting
MCF10A_meta <- MCF10A_ssGSEA@meta.data

# # Sanity check
# table(MCF10A_meta$CultureCondition)

# df to compute group-wise averages
MCF10A_ssgsea_df_z <- as.data.frame(t(MCF10A_ssgsea_mat_z))  # now: rows = cells, cols = pathways
MCF10A_ssgsea_df_z$CultureCondition <- MCF10A_meta$CultureCondition

# Average by Pattern/Random. Then make rows = pathways and columns = pattern or random
MCF10A_avg_ssgsea_z <- MCF10A_ssgsea_df_z %>%
  group_by(CultureCondition) %>%
  summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE))) %>%
  column_to_rownames("CultureCondition") %>%
  t() 

# pheatmap(
#   MCF10A_avg_ssgsea_z,
#   slot = "data",
#   scale = "none",
#   cluster_rows = FALSE,
#   cluster_cols = FALSE,
#   fontsize_row = 9,
#   main = "Average ssGSEA Z Scores for MCF10A"
# )
```

```{r}
# MCF7

# Set to use the correct assay
DefaultAssay(ssGSEA_PatRanxCell) <- "ssGSEA_z"

# Subset MCF10A
MCF7_ssGSEA <- subset(ssGSEA_PatRanxCell, subset = CellLine == "MCF7")

# Extract ssGSEA_z matrix
MCF7_ssgsea_mat_z <- GetAssayData(MCF7_ssGSEA, slot = "data")

# Grab metadata for plotting
MCF7_meta <- MCF7_ssGSEA@meta.data

# # Sanity check
# table(MCF7_meta$CultureCondition)

# df to compute group-wise averages
MCF7_ssgsea_df_z <- as.data.frame(t(MCF7_ssgsea_mat_z))  # now: rows = cells, cols = pathways
MCF7_ssgsea_df_z$CultureCondition <- MCF7_meta$CultureCondition

# Average by Pattern/Random. Then make rows = pathways and columns = pattern or random
MCF7_avg_ssgsea_z <- MCF7_ssgsea_df_z %>%
  group_by(CultureCondition) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  column_to_rownames("CultureCondition") %>%
  t() 

# pheatmap(
#   MCF7_avg_ssgsea_z,
#   slot = "data",
#   scale = "none",
#   cluster_rows = FALSE,
#   cluster_cols = FALSE,
#   fontsize_row = 9,
#   main = "Average ssGSEA Z Scores for MCF7"
# )
```

```{r}
# Fibroblast

# Set to use the correct assay
DefaultAssay(ssGSEA_PatRanxCell) <- "ssGSEA_z"

# Subset MCF10A
FB_ssGSEA <- subset(ssGSEA_PatRanxCell, subset = CellLine == "Fibroblast")

# Extract ssGSEA_z matrix
FB_ssgsea_mat_z <- GetAssayData(FB_ssGSEA, slot = "data")

# Grab metadata for plotting
FB_meta <- FB_ssGSEA@meta.data

# # Sanity check
# table(FB_meta$CultureCondition)

# df to compute group-wise averages
FB_ssgsea_df_z <- as.data.frame(t(FB_ssgsea_mat_z))  # now: rows = cells, cols = pathways
FB_ssgsea_df_z$CultureCondition <- FB_meta$CultureCondition

# Average by Pattern/Random. Then make rows = pathways and columns = pattern or random
FB_avg_ssgsea_z <- FB_ssgsea_df_z %>%
  group_by(CultureCondition) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  column_to_rownames("CultureCondition") %>%
  t() 

# pheatmap(
#   FB_avg_ssgsea_z,
#   slot = "data",
#   scale = "none",
#   cluster_rows = FALSE,
#   cluster_cols = FALSE,
#   fontsize_row = 9,
#   main = "Average ssGSEA Z Scores for FB")
```

```{r}
# MERGED

# Rename columns before cbind to prevent duplicates
colnames(MCF10A_avg_ssgsea_z) <- paste0("MCF10A_", colnames(MCF10A_avg_ssgsea_z))

colnames(MCF7_avg_ssgsea_z)   <- paste0("MCF7_", colnames(MCF7_avg_ssgsea_z))

colnames(FB_avg_ssgsea_z)     <- paste0("FB_", colnames(FB_avg_ssgsea_z))

# Make sure all rows (pathways) are in the same order
all_equal_rownames <- identical(rownames(MCF10A_avg_ssgsea_z), rownames(MCF7_avg_ssgsea_z)) &&
                      identical(rownames(MCF10A_avg_ssgsea_z), rownames(FB_avg_ssgsea_z))
if (!all_equal_rownames) {
  stop("Pathway rows do not match  fix before merging.")
}

# Combine
combined_mat <- cbind(MCF10A_avg_ssgsea_z, MCF7_avg_ssgsea_z, FB_avg_ssgsea_z)
```

### Averaged ssGSEA z-Score across cell types - Pat vs Ran
```{r}
# Clean up the naming and formatting of the pathways
hallmark_titles <- c(
  "HALLMARK-E2F-TARGETS"                        = "E2F Targets",
  "HALLMARK-G2M-CHECKPOINT"                     = "G2M Checkpoint",
  "HALLMARK-MYC-TARGETS-V1"                     = "MYC Targets v1",
  "HALLMARK-MYC-TARGETS-V2"                     = "MYC Targets v2",
  "HALLMARK-P53-PATHWAY"                        = "P53 Pathway",
  "HALLMARK-TGF-BETA-SIGNALING"                 = "TGF Signaling",
  "HALLMARK-APOPTOSIS"                          = "Apoptosis",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE"          = "Unfolded Protein Response",
  "HALLMARK-DNA-REPAIR"                         = "DNA Repair",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION"  = "Epithelial Mesenchymal Transition",
  "HALLMARK-APICAL-JUNCTION"                    = "Apical Junction",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION"          = "Oxidative Phosphorylation",
  "HALLMARK-GLYCOLYSIS"                         = "Glycolysis",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE"          = "IFN- Response",
  "HALLMARK-COMPLEMENT"                         = "Complement",
  "HALLMARK-INFLAMMATORY-RESPONSE"              = "Inflammatory Response",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB"            = "TNF / NF-B Signaling",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING"            = "IL6 / JAK / STAT3 Signaling",
  "HALLMARK-ANGIOGENESIS"                       = "Angiogenesis"
)

tidy_label <- function(pathways) {
  pathways %>%
    sub("^(HALLMARK[_ ]?)", "", ., ignore.case = TRUE) %>%
    tolower() %>%
    gsub("_", " ", .) %>%
    gsub("-", " ", .) %>%
    tools::toTitleCase()
}

# Enforce  typography rules on labels 
fix_pathway_labels <- function(labs) {
  labs <- as.character(labs)
  # --- Core acronym enforcement ---
  labs <- gsub("\\bE2f\\b", "E2F", labs)
  labs <- gsub("\\bG2m\\b", "G2M", labs)
  labs <- gsub("\\bMyc\\b", "MYC", labs)
  labs <- gsub("\\bDna\\b", "DNA", labs)
  labs <- gsub("\\bEmt\\b", "EMT", labs)
  labs <- gsub("\\bJak\\b", "JAK", labs)
  labs <- gsub("\\bStat3\\b", "STAT3", labs)
  labs <- gsub("\\bIl6\\b", "IL6", labs)
  # --- TGF (force uppercase, no space) ---
  labs <- gsub("Tgf\\s*", "TGF", labs)
  labs <- gsub("TGF\\s*", "TGF", labs)
  # --- TNF ---
  labs <- gsub("Tnf\\s*", "TNF", labs)
  labs <- gsub("\\bTnf\\b", "TNF", labs)
  # --- NF-B ---
  labs <- gsub("NF\\s*[-]?\\s*b", "NF-B", labs, ignore.case = TRUE)
  # --- IFN- ---
  labs <- gsub(
    "(?i)(interferon\\s*(gamma||y)|ifn)\\s*[-]?\\s*(gamma||y)?\\s*response",
    "IFN- Response",
    labs,
    perl = TRUE
  )
  labs <- gsub("(?i)ifn\\s*[-]?\\s*(gamma||y)", "IFN-", labs, perl = TRUE)

  labs
}

# Apply mapping
rn_raw <- rownames(combined_mat)

rn_key <- toupper(rn_raw)
rn_key <- gsub("_", "-", rn_key)
rn_key <- gsub("^HALLMARK[ -]?", "HALLMARK-", rn_key)

mapped <- unname(hallmark_titles[rn_key])

# Fallback if already renamed or unexpected IDs
missing <- is.na(mapped)
if (any(missing)) {
  mapped[missing] <- tidy_label(rn_raw[missing])
}

# Final typography enforcement 
rownames(combined_mat) <- fix_pathway_labels(mapped)

# # Sanity check
# head(combined_mat)

# Make stacked top annotation bars 
cell_line <- rep(c("MCF10A", "MCF7", "Fibroblast"), each = 2)
condition <- rep(c("Pattern", "Random"), times = 3)

# Put in a data frame
top_anno_df <- data.frame(
  CellLine   = cell_line,
  Condition  = condition)

rownames(top_anno_df) <- colnames(combined_mat)

# Force the orders 
top_anno_df$CellLine   <- factor(top_anno_df$CellLine,   levels = c("MCF10A", "MCF7", "Fibroblast"))

top_anno_df$Condition  <- factor(top_anno_df$Condition,  levels = c("Pattern", "Random"))

# Annotation bar colors
anno_colors <- list(
  CellLine = c(
    MCF10A     = "#D15B5D",
    MCF7       = "#D795D1",
    Fibroblast = "#718F77"
  ),
  Condition = c(
    Pattern = "#796089",
    Random  = "#DD9358"
  )
)

# Build the top annotation bar
top_annotation <- HeatmapAnnotation(
  df = top_anno_df,
  col = anno_colors,
  show_annotation_name = FALSE,
  annotation_name_side = "right",
  annotation_name_gp = gpar(fontsize = 9),
  annotation_legend_param = list(
    CellLine = list(title = "Cell Type"),
    Condition = list(title = "Condition")
  )
)

# Make little gaps between MCF10A, MCF7, and FB to discourage cross comparisons
column_split <- factor(rep(c("MCF10A", "MCF7", "Fibroblast"), each = 2))

# Make little gaps between the cancer hallmark clustering
row_group_labels <- factor(c(
  rep("Sustaining\nProliferative\nSignaling", 4),
  rep("Evading\nGrowth\nSuppressors", 2),
  rep("Resisting\nCell Death", 2),
  rep("Genome\nInstability", 1),
  rep("Activating\nInvasion &\nMetastasis", 2),
  rep("Deregulating\nCellular\nMetabolism", 2),
  rep("Avoiding\nImmune\nDestruction", 3),
  rep("Tumor\nPromoting\nInflammation", 2),
  rep("Inducing\nAngiogenesis", 1)
), levels = c(
  "Sustaining\nProliferative\nSignaling",
  "Evading\nGrowth\nSuppressors",
  "Resisting\nCell Death",
  "Genome\nInstability",
  "Activating\nInvasion &\nMetastasis",
  "Deregulating\nCellular\nMetabolism",
  "Avoiding\nImmune\nDestruction",
  "Tumor\nPromoting\nInflammation",
  "Inducing\nAngiogenesis"
))

# Force cell type order
column_split <- factor(
  dplyr::case_when(
    grepl("^MCF10A", colnames(combined_mat)) ~ "MCF10A",
    grepl("^MCF7",   colnames(combined_mat)) ~ "MCF7",
    grepl("^FB",     colnames(combined_mat)) ~ "Fibroblast"
  ),
  levels = c("MCF10A", "MCF7", "Fibroblast")
)

range(combined_mat, na.rm = TRUE)

# Legend color scheme and limits
col_RWB <- colorRamp2(c(-0.5, 0, 0.5), c("blue", "white", "red"))

HeatMap_ssGSEA_zScore_PatRan <- Heatmap(
  combined_mat,
  name = "Z Score",
  col = col_RWB,
  top_annotation = top_annotation,
  row_names_side = "left",
  row_names_gp = gpar(fontsize = 12),
  row_split = row_group_labels,
  row_title_side = "right",
  row_title_gp = gpar(fontsize = 10.5),
  row_title_rot = 0,
  column_split = column_split,
  show_column_names = FALSE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_title = "Average ssGSEA Z-Scores Across Cell Lines",
  heatmap_legend_param = list(
    title = "ssGSEA\nZ-score",
    at = c(-0.6, 0, 0.6),
    color_bar = "continuous"
  ),
  row_gap = unit(1.5, "mm"),
  column_gap = unit(2, "mm")
)

# Delete the file if it already exists
if (file.exists("HeatMap_ssGSEA_zScore_PatRan.png")) {
  file.remove("HeatMap_ssGSEA_zScore_PatRan.png")
}

# Save as PNG
png(
  filename = "HeatMap_ssGSEA_zScore_PatRan.png",
  width  = 9,
  height = 8,
  units  = "in",
  res    = 300
)

draw(
  HeatMap_ssGSEA_zScore_PatRan,
  padding = unit(c(5, 5, 5, 20), "mm")
)

dev.off()

HeatMap_ssGSEA_zScore_PatRan
```


### All Pattern and Random Samples Displayed
```{r}
ssGSEA_PatRanxCell <- subset(
  scPrint2_merged_ssGSEA,
  subset = PrintPattern %in% c("Pattern_1","Pattern_2","Pattern_3",
                              "Random_1","Random_2","Random_3")
)
DefaultAssay(ssGSEA_PatRanxCell) <- "ssGSEA_z"

# Helper: average within each PrintPattern for a given CellLine
.avg_by_printpattern <- function(obj, cell_line, rep_order) {
  obj_cl <- subset(obj, subset = CellLine == cell_line)
  mat    <- GetAssayData(obj_cl, slot = "data")   # pathways x cells
  meta   <- obj_cl@meta.data

  df <- as.data.frame(t(mat))                    
  df$PrintPattern <- meta$PrintPattern

  avg <- df %>%
    dplyr::group_by(PrintPattern) %>%
    dplyr::summarise(dplyr::across(where(is.numeric), \(x) mean(x, na.rm = TRUE)), .groups = "drop") %>%
    tibble::column_to_rownames("PrintPattern") %>%
    t()                                     

  # enforce column order (Pattern_1..Random_3)
  avg <- avg[, rep_order, drop = FALSE]

  avg
}

cl_order  <- c("MCF10A","MCF7","Fibroblast")
rep_order <- c("Pattern_1","Pattern_2","Pattern_3","Random_1","Random_2","Random_3")

mat_10A <- .avg_by_printpattern(ssGSEA_PatRanxCell, "MCF10A",     rep_order)
mat_7   <- .avg_by_printpattern(ssGSEA_PatRanxCell, "MCF7",       rep_order)
mat_FB  <- .avg_by_printpattern(ssGSEA_PatRanxCell, "Fibroblast", rep_order)

stopifnot(identical(rownames(mat_10A), rownames(mat_7)))
stopifnot(identical(rownames(mat_10A), rownames(mat_FB)))

# Combine (unique colnames for ComplexHeatmap)
colnames(mat_10A) <- paste0("MCF10A__",     colnames(mat_10A))
colnames(mat_7)   <- paste0("MCF7__",       colnames(mat_7))
colnames(mat_FB)  <- paste0("Fibroblast__", colnames(mat_FB))

combined_mat_reps <- cbind(mat_10A, mat_7, mat_FB)

# Row name formatting 
rn_raw <- rownames(combined_mat_reps)

rn_key <- toupper(rn_raw)
rn_key <- gsub("_", "-", rn_key)
rn_key <- gsub("^HALLMARK[ -]?", "HALLMARK-", rn_key)

mapped <- unname(hallmark_titles[rn_key])

missing <- is.na(mapped)
if (any(missing)) {
  mapped[missing] <- tidy_label(rn_raw[missing])
}

rownames(combined_mat_reps) <- fix_pathway_labels(mapped)

# Column annotations and splits
column_split_reps <- factor(
  dplyr::case_when(
    grepl("^MCF10A__",     colnames(combined_mat_reps)) ~ "MCF10A",
    grepl("^MCF7__",       colnames(combined_mat_reps)) ~ "MCF7",
    grepl("^Fibroblast__", colnames(combined_mat_reps)) ~ "Fibroblast",
    TRUE ~ NA_character_
  ),
  levels = cl_order
)

rep_labels  <- sub("^[^_]+__", "", colnames(combined_mat_reps))          # Pattern_1 ...
cond_labels <- ifelse(grepl("^Pattern", rep_labels), "Pattern", "Random")

top_anno_df_reps <- data.frame(
  CellLine   = factor(as.character(column_split_reps), levels = cl_order),
  Condition  = factor(cond_labels, levels = c("Pattern","Random")),
  row.names  = colnames(combined_mat_reps)
)

top_annotation_reps <- HeatmapAnnotation(
  df = top_anno_df_reps,
  col = anno_colors,
  show_annotation_name = FALSE,
  annotation_legend_param = list(
    CellLine   = list(title = "Cell Type"),
    Condition  = list(title = "Condition")
  )
)

bottom_annotation_reps <- HeatmapAnnotation(
  Replicate = anno_text(rep_labels, rot = 45, just = "right", gp = gpar(fontsize = 9)),
  annotation_name_side = "left",
  which = "column"
)

# Heatmap
HeatMap_ssGSEA_zScore_PatRan_Replicates <- Heatmap(
  combined_mat_reps,
  name = "Z Score",
  col = col_RWB,
  top_annotation = top_annotation_reps,
  bottom_annotation = bottom_annotation_reps,
  row_names_side = "left",
  row_names_gp = gpar(fontsize = 12),
  row_split = row_group_labels,
  row_title_side = "right",
  row_title_gp = gpar(fontsize = 10.5),
  row_title_rot = 0,
  column_split = column_split_reps,
  show_column_names = FALSE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_title = "ssGSEA Z-Scores per Replicate (Pattern_1..Random_3) by Cell Line",
  heatmap_legend_param = list(
    title = "ssGSEA\nZ-score",
    at = c(-0.6, 0, 0.6),
    color_bar = "continuous"
  ),
  row_gap = unit(1.5, "mm"),
  column_gap = unit(2, "mm")
)

# Delete the file if it already exists
if (file.exists("HeatMap_ssGSEA_zScore_PatRan_Replicates.png")) {
  file.remove("HeatMap_ssGSEA_zScore_PatRan_Replicates.png")
}

# Save as PNG
png(filename = "HeatMap_ssGSEA_zScore_PatRan_Replicates.png",
  width  = 13,
  height = 8,
  units  = "in",
  res    = 300
)

draw(
  HeatMap_ssGSEA_zScore_PatRan_Replicates,
  padding = unit(c(5, 5, 5, 20), "mm")
)

dev.off()

HeatMap_ssGSEA_zScore_PatRan_Replicates
```

```{r}
# Range of z-scores in the heatmap 
range(combined_mat_reps, na.rm = TRUE)

quantile(
  combined_mat_reps,
  probs = c(0.001, 0.01, 0.05, 0.95, 0.99, 0.999),
  na.rm = TRUE)
```



### Averaged Pat v Ran v Ctr 
```{r}
ssGSEA_Avg_All <- subset(
  scPrint2_merged_ssGSEA,
  subset = PrintPattern %in% c(
    "Pattern_1","Pattern_2","Pattern_3",
    "Random_1","Random_2","Random_3",
    "MCF10A_CTRL","MCF7_CTRL","Fibroblast_CTRL"
  )
)
DefaultAssay(ssGSEA_Avg_All) <- "ssGSEA_z"

hallmark_titles <- c(
  "HALLMARK-E2F-TARGETS"                        = "E2F Targets",
  "HALLMARK-G2M-CHECKPOINT"                     = "G2M Checkpoint",
  "HALLMARK-MYC-TARGETS-V1"                     = "MYC Targets v1",
  "HALLMARK-MYC-TARGETS-V2"                     = "MYC Targets v2",
  "HALLMARK-P53-PATHWAY"                        = "P53 Pathway",
  "HALLMARK-TGF-BETA-SIGNALING"                 = "TGF Signaling",
  "HALLMARK-APOPTOSIS"                          = "Apoptosis",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE"          = "Unfolded Protein Response",
  "HALLMARK-DNA-REPAIR"                         = "DNA Repair",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION"  = "Epithelial Mesenchymal Transition",
  "HALLMARK-APICAL-JUNCTION"                    = "Apical Junction",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION"          = "Oxidative Phosphorylation",
  "HALLMARK-GLYCOLYSIS"                         = "Glycolysis",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE"          = "IFN- Response",
  "HALLMARK-COMPLEMENT"                         = "Complement",
  "HALLMARK-INFLAMMATORY-RESPONSE"              = "Inflammatory Response",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB"            = "TNF / NF-B Signaling",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING"            = "IL6 / JAK / STAT3 Signaling",
  "HALLMARK-ANGIOGENESIS"                       = "Angiogenesis"
)

tidy_label <- function(pathways) {
  pathways %>%
    sub("^(HALLMARK[_ ]?)", "", ., ignore.case = TRUE) %>%
    tolower() %>%
    gsub("_", " ", .) %>%
    gsub("-", " ", .) %>%
    tools::toTitleCase()
}

fix_pathway_labels <- function(labs) {
  labs <- as.character(labs)
  labs <- gsub("\\bE2f\\b", "E2F", labs)
  labs <- gsub("\\bG2m\\b", "G2M", labs)
  labs <- gsub("\\bMyc\\b", "MYC", labs)
  labs <- gsub("\\bDna\\b", "DNA", labs)
  labs <- gsub("\\bEmt\\b", "EMT", labs)
  labs <- gsub("\\bJak\\b", "JAK", labs)
  labs <- gsub("\\bStat3\\b", "STAT3", labs)
  labs <- gsub("\\bIl6\\b", "IL6", labs)
  labs <- gsub("Tgf\\s*", "TGF", labs)
  labs <- gsub("TGF\\s*", "TGF", labs)
  labs <- gsub("Tnf\\s*", "TNF", labs)
  labs <- gsub("\\bTnf\\b", "TNF", labs)
  labs <- gsub("NF\\s*[-]?\\s*b", "NF-B", labs, ignore.case = TRUE)
  labs <- gsub(
    "(?i)(interferon\\s*(gamma||y)|ifn)\\s*[-]?\\s*(gamma||y)?\\s*response",
    "IFN- Response",
    labs,
    perl = TRUE
  )
  labs <- gsub("(?i)ifn\\s*[-]?\\s*(gamma||y)", "IFN-", labs, perl = TRUE)
  labs
}

# Build averages for each CellLine: mean(Pattern_1..3), mean(Random_1..3), mean(Control)
.avg_threeway <- function(obj, cell_line) {
  obj_cl <- subset(obj, subset = CellLine == cell_line)

  mat  <- GetAssayData(obj_cl, slot = "data")   
  meta <- obj_cl@meta.data

  df <- as.data.frame(t(mat))                
  df$PrintPattern <- meta$PrintPattern

  df <- df %>%
    mutate(Group = case_when(
      PrintPattern %in% c("Pattern_1","Pattern_2","Pattern_3") ~ "Pattern",
      PrintPattern %in% c("Random_1","Random_2","Random_3")   ~ "Random",
      PrintPattern == paste0(cell_line, "_CTRL")              ~ "Control",
      TRUE ~ NA_character_
    )) %>%
    filter(!is.na(Group))

  avg <- df %>%
    group_by(Group) %>%
    summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE)), .groups = "drop") %>%
    column_to_rownames("Group") %>%
    t()  

  # enforce column order and names
  avg <- avg[, c("Pattern","Random","Control"), drop = FALSE]
  colnames(avg) <- c(
    paste0(cell_line, "_Pattern"),
    paste0(cell_line, "_Random"),
    paste0(cell_line, "_Control")
  )

  avg
}

mat_10A <- .avg_threeway(ssGSEA_Avg_All, "MCF10A")
mat_7   <- .avg_threeway(ssGSEA_Avg_All, "MCF7")
mat_FB  <- .avg_threeway(ssGSEA_Avg_All, "Fibroblast")

stopifnot(identical(rownames(mat_10A), rownames(mat_7)))
stopifnot(identical(rownames(mat_10A), rownames(mat_FB)))

combined_mat_avg3 <- cbind(mat_10A, mat_7, mat_FB)

rn_raw <- rownames(combined_mat_avg3)

rn_key <- toupper(rn_raw)
rn_key <- gsub("_", "-", rn_key)
rn_key <- gsub("^HALLMARK[ -]?", "HALLMARK-", rn_key)

mapped <- unname(hallmark_titles[rn_key])
missing <- is.na(mapped)
if (any(missing)) mapped[missing] <- tidy_label(rn_raw[missing])

rownames(combined_mat_avg3) <- fix_pathway_labels(mapped)

cl_order <- c("MCF10A","MCF7","Fibroblast")

cell_line <- case_when(
  grepl("^MCF10A_", colnames(combined_mat_avg3))     ~ "MCF10A",
  grepl("^MCF7_",   colnames(combined_mat_avg3))     ~ "MCF7",
  grepl("^Fibroblast_", colnames(combined_mat_avg3)) ~ "Fibroblast",
  TRUE ~ NA_character_
)

condition <- case_when(
  grepl("_Pattern$",  colnames(combined_mat_avg3)) ~ "Pattern",
  grepl("_Random$",   colnames(combined_mat_avg3)) ~ "Random",
  grepl("_Control$",  colnames(combined_mat_avg3)) ~ "Control",
  TRUE ~ NA_character_
)

top_anno_df <- data.frame(
  CellLine  = factor(cell_line,  levels = cl_order),
  Condition = factor(condition,  levels = c("Pattern","Random","Control")),
  row.names = colnames(combined_mat_avg3)
)

anno_colors <- list(
  CellLine = c(
    MCF10A     = "#D15B5D",
    MCF7       = "#D795D1",
    Fibroblast = "#718F77"
  ),
  Condition = c(
    Pattern = "#796089",
    Random  = "#DD9358",
    Control = "#AFABAB"
  )
)

top_annotation <- HeatmapAnnotation(
  df = top_anno_df,
  col = anno_colors,
  show_annotation_name = FALSE,
  annotation_legend_param = list(
    CellLine   = list(title = "Cell Type"),
    Condition  = list(title = "Condition", at = c("Pattern","Random","Control"))
  )
)

# Split columns by cell line to create gaps
column_split <- factor(top_anno_df$CellLine, levels = cl_order)

row_group_labels <- factor(c(
  rep("Sustaining\nProliferative\nSignaling", 4),
  rep("Evading\nGrowth\nSuppressors", 2),
  rep("Resisting\nCell Death", 2),
  rep("Genome\nInstability", 1),
  rep("Activating\nInvasion &\nMetastasis", 2),
  rep("Deregulating\nCellular\nMetabolism", 2),
  rep("Avoiding\nImmune\nDestruction", 3),
  rep("Tumor\nPromoting\nInflammation", 2),
  rep("Inducing\nAngiogenesis", 1)
), levels = c(
  "Sustaining\nProliferative\nSignaling",
  "Evading\nGrowth\nSuppressors",
  "Resisting\nCell Death",
  "Genome\nInstability",
  "Activating\nInvasion &\nMetastasis",
  "Deregulating\nCellular\nMetabolism",
  "Avoiding\nImmune\nDestruction",
  "Tumor\nPromoting\nInflammation",
  "Inducing\nAngiogenesis"
))

# Pick values for the legend scale. Adjust based on the actual range of the data
lims <- 1
col_RWB <- colorRamp2(c(-lims, 0, lims), c("blue", "white", "red"))

HeatMap_ssGSEA_zScore_PatRan_Control_AVERAGED <- Heatmap(
  combined_mat_avg3,
  name = "Z Score",
  col = col_RWB,
  top_annotation = top_annotation,
  row_names_side = "left",
  row_names_gp = gpar(fontsize = 12),
  row_split = row_group_labels,
  row_title_side = "right",
  row_title_gp = gpar(fontsize = 10.5),
  row_title_rot = 0,
  column_split = column_split,
  show_column_names = FALSE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_title = "Average ssGSEA Z-Scores Across Cell Lines (Pattern vs Random vs Control)",
  heatmap_legend_param = list(
    title = "ssGSEA\nZ-score",
    at = c(-1, 0, 1),
    color_bar = "continuous"
  ),
  row_gap = unit(1.5, "mm"),
  column_gap = unit(2, "mm")
)

# Save
out_file <- "HeatMap_ssGSEA_zScore_PatRan_Control_AVERAGED.png"
if (file.exists(out_file)) file.remove(out_file)

png(filename = out_file, width = 10, height = 8, units = "in", res = 300)
draw(HeatMap_ssGSEA_zScore_PatRan_Control_AVERAGED, padding = unit(c(5, 5, 5, 20), "mm"))
dev.off()

HeatMap_ssGSEA_zScore_PatRan_Control_AVERAGED

```

## Vln/Box plots
### MCF10A with Control
```{r}
# Loop through all the hallmarks for MCF10A

MCF10A_ssGSEA_ALLxCell <- subset(
  scPrint2_merged_ssGSEA,
  subset = PrintPattern %in% c(
    "Pattern_1", "Pattern_2", "Pattern_3",
    "Random_1",  "Random_2",  "Random_3",
    "MCF10A_CTRL"))

MCF10A_ssGSEA_ALLxCell <- subset(
  MCF10A_ssGSEA_ALLxCell,
  subset = CellLine == "MCF10A")

DefaultAssay(MCF10A_ssGSEA_ALLxCell) <- "ssGSEA_z"

cell_line <- "MCF10A"

# Formatted titles for each Hallmark
hallmark_titles <- c(
  "HALLMARK-E2F-TARGETS"                        = "E2F Targets",
  "HALLMARK-G2M-CHECKPOINT"                     = "G2M Checkpoint",
  "HALLMARK-MYC-TARGETS-V1"                     = "MYC Targets v1",
  "HALLMARK-MYC-TARGETS-V2"                     = "MYC Targets v2",
  "HALLMARK-P53-PATHWAY"                        = "P53 Pathway",
  "HALLMARK-TGF-BETA-SIGNALING"                 = "TGF- Signaling",
  "HALLMARK-APOPTOSIS"                          = "Apoptosis",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE"          = "Unfolded Protein Response",
  "HALLMARK-DNA-REPAIR"                         = "DNA Repair",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION"  = "EMT",
  "HALLMARK-APICAL-JUNCTION"                    = "Apical Junction",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION"          = "Oxidative Phosphorylation",
  "HALLMARK-GLYCOLYSIS"                         = "Glycolysis",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE"          = "IFN- Response",
  "HALLMARK-COMPLEMENT"                         = "Complement",
  "HALLMARK-INFLAMMATORY-RESPONSE"              = "Inflammatory Response",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB"            = "TNF / NF-B Signaling",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING"            = "IL6 / JAK / STAT3 Signaling",
  "HALLMARK-ANGIOGENESIS"                       = "Angiogenesis")

# Helper: make one plot for a given Hallmark
make_MCF10A_hallmark_plot <- function(box_pw, cell_line = "MCF10A") {

  # Pull per-spot ssGSEA z-scores + metadata
  df_box <- FetchData(
    MCF10A_ssGSEA_ALLxCell,
    vars = c("CultureCondition", box_pw, "CellLine")
  )
  colnames(df_box)[2] <- "Score"

  # Keep only this cell line and Pattern/Random/Control
  Comp_of_Interest <- df_box %>%
    filter(
      CellLine %in% cell_line,
      CultureCondition %in% c("Pattern", "Random", "Control")
    ) %>%
    mutate(
      CultureCondition = factor(
        CultureCondition,
        levels = c("Pattern", "Random", "Control")
      )
    )

  
  # Pairwise Wilcoxon (BH)
  pair_res <- pairwise.wilcox.test(
    Comp_of_Interest$Score,
    Comp_of_Interest$CultureCondition,
    p.adjust.method = "BH"
  )

  get_p <- function(mat, g1, g2) {
    rn <- rownames(mat); cn <- colnames(mat)
    if (g1 %in% rn && g2 %in% cn) return(mat[g1, g2])
    if (g2 %in% rn && g1 %in% cn) return(mat[g2, g1])
    NA_real_
  }

  comparisons_emt <- list(
    c("Pattern", "Random"),
    c("Random",  "Control"),
    c("Pattern", "Control")
  )

  star_from_p <- function(p) {
    if (is.na(p))   return(NA_character_)
    if (p < 1e-4)   return("****")
    if (p < 1e-3)   return("***")
    if (p < 1e-2)   return("**")
    if (p < 0.05)   return("*")
    "ns"
  }

  p_vals  <- sapply(comparisons_emt, function(x) get_p(pair_res$p.value, x[1], x[2]))
  labels  <- sapply(p_vals, star_from_p)

  stat_df <- tibble(
    group1 = sapply(comparisons_emt, `[`, 1),
    group2 = sapply(comparisons_emt, `[`, 2),
    p      = p_vals,
    label  = labels
  ) %>%
    filter(!is.na(label), label != "ns")


  # Y positions of sig brackets
  score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
  score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
  height    <- score_max - score_min
  if (height == 0) height <- 1

  base_y <- score_max + 0.05 * height
  step_y <- 0.10 * height

  if (nrow(stat_df) > 0) {
    stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)
  }

  ylim_top <- if (nrow(stat_df) > 0) {
    max(stat_df$y.position, na.rm = TRUE) + 0.05 * height
  } else {
    score_max + 0.1 * height
  }


  # y-axis lower limit and breaks  per plot
  y_min    <- floor(min(score_min, 0) * 2) / 2
  y_breaks <- pretty(c(y_min, ylim_top), n = 5)


  # Format title for this pathway
  plot_title <- unname(hallmark_titles[box_pw])
  if (length(plot_title) == 0 || is.na(plot_title)) {
    plot_title <- box_pw
  }


  # Plot
  p <- ggplot(
    Comp_of_Interest,
    aes(x = CultureCondition, y = Score)
  ) +
    geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.01,
          bracket.size = 0.5
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank()
    )

  # File name: use Hallmark ID
  safe_name <- gsub("^HALLMARK-", "", box_pw)
  safe_name <- gsub("-", "_", safe_name)
  file_name <- paste0("MCF10A_", safe_name, "_BoxPlot.png")

  if (file.exists(file_name)) {
    file.remove(file_name)
  }

  ggsave(
    filename = file_name,
    plot     = p,
    width    = 1.8,
    height   = 1.5,
    dpi      = 300,
    units    = "in"
  )

  p
}


# Hallmark pathways to loop through
hallmarks <- c(
  "HALLMARK-E2F-TARGETS",
  "HALLMARK-G2M-CHECKPOINT",
  "HALLMARK-MYC-TARGETS-V1",
  "HALLMARK-MYC-TARGETS-V2",
  "HALLMARK-P53-PATHWAY",
  "HALLMARK-TGF-BETA-SIGNALING",
  "HALLMARK-APOPTOSIS",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE",
  "HALLMARK-DNA-REPAIR",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION",
  "HALLMARK-APICAL-JUNCTION",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION",
  "HALLMARK-GLYCOLYSIS",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE",
  "HALLMARK-COMPLEMENT",
  "HALLMARK-INFLAMMATORY-RESPONSE",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING",
  "HALLMARK-ANGIOGENESIS"
)

for (pw in hallmarks) {
  message("Making plot for ", pw)
  make_MCF10A_hallmark_plot(pw)
}
```


#### Format Fix For Publication
##### Apical Junction
```{r}
box_pw <- "HALLMARK-APICAL-JUNCTION"   

df_box <- FetchData(
  MCF10A_ssGSEA_ALLxCell,
  vars = c("CultureCondition", box_pw, "CellLine")
)

colnames(df_box)[2] <- "Score"

Comp_of_Interest <- df_box |> 
  dplyr::filter(
    CellLine == "MCF10A",
    CultureCondition %in% c("Pattern", "Random", "Control")
  ) |>
  dplyr::mutate(
    CultureCondition = factor(
      CultureCondition,
      levels = c("Pattern", "Random", "Control")
    )
  )

# Stats
pair_res <- pairwise.wilcox.test(
  Comp_of_Interest$Score,
  Comp_of_Interest$CultureCondition,
  p.adjust.method = "BH"
)

get_p <- function(mat, g1, g2) {
  rn <- rownames(mat); cn <- colnames(mat)
  if (g1 %in% rn && g2 %in% cn) return(mat[g1,g2])
  if (g2 %in% rn && g1 %in% cn) return(mat[g2,g1])
  NA_real_
}

comparisons <- list(
  c("Pattern","Random"),
  c("Random","Control"),
  c("Pattern","Control")
)

star_from_p <- function(p){
  if (is.na(p)) return(NA_character_)
  if (p < 1e-4) return("****")
  if (p < 1e-3) return("***")
  if (p < 1e-2) return("**")
  if (p < 0.05) return("*")
  "ns"
}

p_vals <- sapply(comparisons, \(x) get_p(pair_res$p.value,x[1],x[2]))
labels <- sapply(p_vals, star_from_p)

stat_df <- tibble::tibble(
  group1 = sapply(comparisons, `[`, 1),
  group2 = sapply(comparisons, `[`, 2),
  label  = labels
) |> dplyr::filter(!is.na(label), label != "ns")

# y-axis frame
score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
height    <- score_max - score_min
if (height == 0) height <- 1

# Manually anchor bracket stack lower
base_y <- 5
step_y <- 0.8        

if (nrow(stat_df) > 0)
  stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)

ylim_top <- if (nrow(stat_df) > 0)
  max(stat_df$y.position) + 0.05 * height else score_max + 0.1 * height

y_min <- floor(min(score_min, 0) * 2) / 2
y_breaks <- pretty(c(y_min, ylim_top), 5)

# Format title
plot_title <- hallmark_titles[box_pw]
if (is.na(plot_title)) plot_title <- box_pw

# Plot
MCF10A_FORMATTED_ApicalJunction_BoxPlot <- ggplot(
  Comp_of_Interest,
  aes(x = CultureCondition, y = Score)
) +
  geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.0,
          bracket.size = 0.3
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank())


# Delete the file if it already exists
if (file.exists("MCF10A_FORMATTED_ApicalJunction_BoxPlot.png")) {
  file.remove("MCF10A_FORMATTED_ApicalJunction_BoxPlot.png")
}

# Save
ggsave(
  filename = "MCF10A_FORMATTED_ApicalJunction_BoxPlot.png",
  plot     = MCF10A_FORMATTED_ApicalJunction_BoxPlot,
  width    = 1.8,
  height   = 1.5,
  dpi      = 300,
  units    = "in"
)

MCF10A_FORMATTED_ApicalJunction_BoxPlot
```
```{r}
Comp_of_Interest |>
  dplyr::group_by(CultureCondition) |>
  dplyr::summarise(
    n      = dplyr::n(),
    median = median(Score, na.rm = TRUE),
    mean   = mean(Score, na.rm = TRUE)
  )
```


#### MCF7 with Control
```{r}
# Loop through all the hallmarks for MCF7

MCF7_ssGSEA_ALLxCell <- subset(
  scPrint2_merged_ssGSEA,
  subset = PrintPattern %in% c(
    "Pattern_1", "Pattern_2", "Pattern_3",
    "Random_1",  "Random_2",  "Random_3",
    "MCF7_CTRL"))

MCF7_ssGSEA_ALLxCell <- subset(
  MCF7_ssGSEA_ALLxCell,
  subset = CellLine == "MCF7")

DefaultAssay(MCF7_ssGSEA_ALLxCell) <- "ssGSEA_z"

cell_line <- "MCF7"

hallmark_titles <- c(
  "HALLMARK-E2F-TARGETS"                        = "E2F Targets",
  "HALLMARK-G2M-CHECKPOINT"                     = "G2M Checkpoint",
  "HALLMARK-MYC-TARGETS-V1"                     = "MYC Targets v1",
  "HALLMARK-MYC-TARGETS-V2"                     = "MYC Targets v2",
  "HALLMARK-P53-PATHWAY"                        = "P53 Pathway",
  "HALLMARK-TGF-BETA-SIGNALING"                 = "TGF- Signaling",
  "HALLMARK-APOPTOSIS"                          = "Apoptosis",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE"          = "Unfolded Protein Response",
  "HALLMARK-DNA-REPAIR"                         = "DNA Repair",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION"  = "EMT",
  "HALLMARK-APICAL-JUNCTION"                    = "Apical Junction",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION"          = "Oxidative Phosphorylation",
  "HALLMARK-GLYCOLYSIS"                         = "Glycolysis",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE"          = "Interferon- Response",
  "HALLMARK-COMPLEMENT"                         = "Complement",
  "HALLMARK-INFLAMMATORY-RESPONSE"              = "Inflammatory Response",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB"            = "TNF / NF-B Signaling",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING"            = "IL6 / JAK / STAT3 Signaling",
  "HALLMARK-ANGIOGENESIS"                       = "Angiogenesis"
)


make_MCF7_hallmark_plot <- function(box_pw, cell_line = "MCF7") {

  # Pull per-spot ssGSEA z-scores + metadata
  df_box <- FetchData(
    MCF7_ssGSEA_ALLxCell,
    vars = c("CultureCondition", box_pw, "CellLine")
  )
  colnames(df_box)[2] <- "Score"

  # Keep only this cell line and Pattern/Random/Control
  Comp_of_Interest <- df_box %>%
    filter(
      CellLine %in% cell_line,
      CultureCondition %in% c("Pattern", "Random", "Control")
    ) %>%
    mutate(
      CultureCondition = factor(
        CultureCondition,
        levels = c("Pattern", "Random", "Control")
      )
    )


  # Pairwise Wilcoxon (BH)
  pair_res <- pairwise.wilcox.test(
    Comp_of_Interest$Score,
    Comp_of_Interest$CultureCondition,
    p.adjust.method = "BH"
  )

  get_p <- function(mat, g1, g2) {
    rn <- rownames(mat); cn <- colnames(mat)
    if (g1 %in% rn && g2 %in% cn) return(mat[g1, g2])
    if (g2 %in% rn && g1 %in% cn) return(mat[g2, g1])
    NA_real_
  }

  comparisons_emt <- list(
    c("Pattern", "Random"),
    c("Random",  "Control"),
    c("Pattern", "Control")
  )

  star_from_p <- function(p) {
    if (is.na(p))   return(NA_character_)
    if (p < 1e-4)   return("****")
    if (p < 1e-3)   return("***")
    if (p < 1e-2)   return("**")
    if (p < 0.05)   return("*")
    "ns"
  }

  p_vals  <- sapply(comparisons_emt, function(x) get_p(pair_res$p.value, x[1], x[2]))
  labels  <- sapply(p_vals, star_from_p)

  stat_df <- tibble(
    group1 = sapply(comparisons_emt, `[`, 1),
    group2 = sapply(comparisons_emt, `[`, 2),
    p      = p_vals,
    label  = labels
  ) %>%
    filter(!is.na(label), label != "ns")


  # Y positions of sig brackets
  score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
  score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
  height    <- score_max - score_min
  if (height == 0) height <- 1

  base_y <- score_max + 0.05 * height
  step_y <- 0.10 * height

  if (nrow(stat_df) > 0) {
    stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)
  }

  ylim_top <- if (nrow(stat_df) > 0) {
    max(stat_df$y.position, na.rm = TRUE) + 0.05 * height
  } else {
    score_max + 0.1 * height
  }


  # y-axis lower limit and breaks  per plot
  y_min    <- floor(min(score_min, 0) * 2) / 2
  y_breaks <- pretty(c(y_min, ylim_top), n = 5)

  
  plot_title <- unname(hallmark_titles[box_pw])
  if (length(plot_title) == 0 || is.na(plot_title)) {
    plot_title <- box_pw
  }

  # Plot
  p <- ggplot(
    Comp_of_Interest,
    aes(x = CultureCondition, y = Score)
  ) +
    geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.01,
          bracket.size = 0.5
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank()
    )

  # File name: use Hallmark ID
  safe_name <- gsub("^HALLMARK-", "", box_pw)
  safe_name <- gsub("-", "_", safe_name)
  file_name <- paste0("MCF7_", safe_name, "_BoxPlot.png")

  if (file.exists(file_name)) {
    file.remove(file_name)
  }

  ggsave(
    filename = file_name,
    plot     = p,
    width    = 1.8,
    height   = 1.5,
    dpi      = 300,
    units    = "in"
  )

  p
}


hallmarks <- c(
  "HALLMARK-E2F-TARGETS",
  "HALLMARK-G2M-CHECKPOINT",
  "HALLMARK-MYC-TARGETS-V1",
  "HALLMARK-MYC-TARGETS-V2",
  "HALLMARK-P53-PATHWAY",
  "HALLMARK-TGF-BETA-SIGNALING",
  "HALLMARK-APOPTOSIS",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE",
  "HALLMARK-DNA-REPAIR",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION",
  "HALLMARK-APICAL-JUNCTION",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION",
  "HALLMARK-GLYCOLYSIS",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE",
  "HALLMARK-COMPLEMENT",
  "HALLMARK-INFLAMMATORY-RESPONSE",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING",
  "HALLMARK-ANGIOGENESIS"
)

for (pw in hallmarks) {
  message("Making MCF7 plot for ", pw)
  make_MCF7_hallmark_plot(pw)
}

```

##### Format Fix For Publication
###### P53
```{r}
box_pw <- "HALLMARK-P53-PATHWAY"   

df_box <- FetchData(
  MCF7_ssGSEA_ALLxCell,
  vars = c("CultureCondition", box_pw, "CellLine")
)

colnames(df_box)[2] <- "Score"

Comp_of_Interest <- df_box |> 
  dplyr::filter(
    CellLine == "MCF7",
    CultureCondition %in% c("Pattern", "Random", "Control")
  ) |>
  dplyr::mutate(
    CultureCondition = factor(
      CultureCondition,
      levels = c("Pattern", "Random", "Control")
    )
  )

# Stats
pair_res <- pairwise.wilcox.test(
  Comp_of_Interest$Score,
  Comp_of_Interest$CultureCondition,
  p.adjust.method = "BH"
)

get_p <- function(mat, g1, g2) {
  rn <- rownames(mat); cn <- colnames(mat)
  if (g1 %in% rn && g2 %in% cn) return(mat[g1,g2])
  if (g2 %in% rn && g1 %in% cn) return(mat[g2,g1])
  NA_real_
}

comparisons <- list(
  c("Pattern","Random"),
  c("Random","Control"),
  c("Pattern","Control")
)

star_from_p <- function(p){
  if (is.na(p)) return(NA_character_)
  if (p < 1e-4) return("****")
  if (p < 1e-3) return("***")
  if (p < 1e-2) return("**")
  if (p < 0.05) return("*")
  "ns"
}

p_vals <- sapply(comparisons, \(x) get_p(pair_res$p.value,x[1],x[2]))
labels <- sapply(p_vals, star_from_p)

stat_df <- tibble::tibble(
  group1 = sapply(comparisons, `[`, 1),
  group2 = sapply(comparisons, `[`, 2),
  label  = labels
) |> dplyr::filter(!is.na(label), label != "ns")

# y-axis frame
score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
height    <- score_max - score_min
if (height == 0) height <- 1

# Manually anchor bracket stack lower
base_y <- 6
step_y <- 0.8        

if (nrow(stat_df) > 0)
  stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)

ylim_top <- if (nrow(stat_df) > 0)
  max(stat_df$y.position) + 0.05 * height else score_max + 0.1 * height

y_min <- floor(min(score_min, 0) * 2) / 2
y_breaks <- pretty(c(y_min, ylim_top), 5)

plot_title <- hallmark_titles[box_pw]
if (is.na(plot_title)) plot_title <- box_pw

# Plot
MCF7_FORMATTED_P53_BoxPlot <- ggplot(
  Comp_of_Interest,
  aes(x = CultureCondition, y = Score)
) +
  geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.0,
          bracket.size = 0.3
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank())


# Delete the file if it already exists
if (file.exists("MCF7_FORMATTED_P53_BoxPlot.png")) {
  file.remove("MCF7_FORMATTED_P53_BoxPlot.png")
}

# Save
ggsave(
  filename = "MCF7_FORMATTED_P53_BoxPlot.png",
  plot     = MCF7_FORMATTED_P53_BoxPlot,
  width    = 1.8,
  height   = 1.5,
  dpi      = 300,
  units    = "in"
)

MCF7_FORMATTED_P53_BoxPlot
```
```{r}
Comp_of_Interest |>
  dplyr::group_by(CultureCondition) |>
  dplyr::summarise(
    n      = dplyr::n(),
    median = median(Score, na.rm = TRUE),
    mean   = mean(Score, na.rm = TRUE)
  )
```


#### FB with Control
```{r}
# Loop through all the hallmarks for Fibroblast

Fibro_ssGSEA_ALLxCell <- subset(
  scPrint2_merged_ssGSEA,
  subset = PrintPattern %in% c(
    "Pattern_1", "Pattern_2", "Pattern_3",
    "Random_1",  "Random_2",  "Random_3",
    "Fibroblast_CTRL"))

Fibro_ssGSEA_ALLxCell <- subset(
  Fibro_ssGSEA_ALLxCell,
  subset = CellLine == "Fibroblast")

DefaultAssay(Fibro_ssGSEA_ALLxCell) <- "ssGSEA_z"

cell_line <- "Fibroblast"

hallmark_titles <- c(
  "HALLMARK-E2F-TARGETS"                        = "E2F Targets",
  "HALLMARK-G2M-CHECKPOINT"                     = "G2M Checkpoint",
  "HALLMARK-MYC-TARGETS-V1"                     = "MYC Targets v1",
  "HALLMARK-MYC-TARGETS-V2"                     = "MYC Targets v2",
  "HALLMARK-P53-PATHWAY"                        = "P53 Pathway",
  "HALLMARK-TGF-BETA-SIGNALING"                 = "TGF- Signaling",
  "HALLMARK-APOPTOSIS"                          = "Apoptosis",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE"          = "Unfolded Protein Response",
  "HALLMARK-DNA-REPAIR"                         = "DNA Repair",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION"  = "EMT",
  "HALLMARK-APICAL-JUNCTION"                    = "Apical Junction",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION"          = "Oxidative Phosphorylation",
  "HALLMARK-GLYCOLYSIS"                         = "Glycolysis",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE"          = "Interferon- Response",
  "HALLMARK-COMPLEMENT"                         = "Complement",
  "HALLMARK-INFLAMMATORY-RESPONSE"              = "Inflammatory Response",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB"            = "TNF / NF-B Signaling",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING"            = "IL6 / JAK / STAT3 Signaling",
  "HALLMARK-ANGIOGENESIS"                       = "Angiogenesis"
)

make_Fibro_hallmark_plot <- function(box_pw, cell_line = "Fibroblast") {

  # Pull per-spot ssGSEA z-scores + metadata
  df_box <- FetchData(
    Fibro_ssGSEA_ALLxCell,
    vars = c("CultureCondition", box_pw, "CellLine")
  )
  colnames(df_box)[2] <- "Score"

  # Keep only this cell line and Pattern/Random/Control
  Comp_of_Interest <- df_box %>%
    filter(
      CellLine %in% cell_line,
      CultureCondition %in% c("Pattern", "Random", "Control")
    ) %>%
    mutate(
      CultureCondition = factor(
        CultureCondition,
        levels = c("Pattern", "Random", "Control")
      )
    )

  # Pairwise Wilcoxon (BH)
  pair_res <- pairwise.wilcox.test(
    Comp_of_Interest$Score,
    Comp_of_Interest$CultureCondition,
    p.adjust.method = "BH"
  )

  get_p <- function(mat, g1, g2) {
    rn <- rownames(mat); cn <- colnames(mat)
    if (g1 %in% rn && g2 %in% cn) return(mat[g1, g2])
    if (g2 %in% rn && g1 %in% cn) return(mat[g2, g1])
    NA_real_
  }

  comparisons_emt <- list(
    c("Pattern", "Random"),
    c("Random",  "Control"),
    c("Pattern", "Control")
  )

  star_from_p <- function(p) {
    if (is.na(p))   return(NA_character_)
    if (p < 1e-4)   return("****")
    if (p < 1e-3)   return("***")
    if (p < 1e-2)   return("**")
    if (p < 0.05)   return("*")
    "ns"
  }

  p_vals  <- sapply(comparisons_emt, function(x) get_p(pair_res$p.value, x[1], x[2]))
  labels  <- sapply(p_vals, star_from_p)

  stat_df <- tibble(
    group1 = sapply(comparisons_emt, `[`, 1),
    group2 = sapply(comparisons_emt, `[`, 2),
    p      = p_vals,
    label  = labels
  ) %>%
    filter(!is.na(label), label != "ns")

  # Y positions of sig brackets
  score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
  score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
  height    <- score_max - score_min
  if (height == 0) height <- 1

  base_y <- score_max + 0.05 * height
  step_y <- 0.10 * height

  if (nrow(stat_df) > 0) {
    stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)
  }

  ylim_top <- if (nrow(stat_df) > 0) {
    max(stat_df$y.position, na.rm = TRUE) + 0.05 * height
  } else {
    score_max + 0.1 * height
  }

  # y-axis lower limit and breaks  per plot
  y_min    <- floor(min(score_min, 0) * 2) / 2
  y_breaks <- pretty(c(y_min, ylim_top), n = 5)

  plot_title <- unname(hallmark_titles[box_pw])
  if (length(plot_title) == 0 || is.na(plot_title)) {
    plot_title <- box_pw
  }

  # Plot
  p <- ggplot(
    Comp_of_Interest,
    aes(x = CultureCondition, y = Score)
  ) +
    geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.01,
          bracket.size = 0.5
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank()
    )

  # File name: use Hallmark ID
  safe_name <- gsub("^HALLMARK-", "", box_pw)
  safe_name <- gsub("-", "_", safe_name)
  file_name <- paste0("Fibro_", safe_name, "_BoxPlot.png")

  if (file.exists(file_name)) {
    file.remove(file_name)
  }

  ggsave(
    filename = file_name,
    plot     = p,
    width    = 1.8,
    height   = 1.5,
    dpi      = 300,
    units    = "in"
  )

  p
}


hallmarks <- c(
  "HALLMARK-E2F-TARGETS",
  "HALLMARK-G2M-CHECKPOINT",
  "HALLMARK-MYC-TARGETS-V1",
  "HALLMARK-MYC-TARGETS-V2",
  "HALLMARK-P53-PATHWAY",
  "HALLMARK-TGF-BETA-SIGNALING",
  "HALLMARK-APOPTOSIS",
  "HALLMARK-UNFOLDED-PROTEIN-RESPONSE",
  "HALLMARK-DNA-REPAIR",
  "HALLMARK-EPITHELIAL-MESENCHYMAL-TRANSITION",
  "HALLMARK-APICAL-JUNCTION",
  "HALLMARK-OXIDATIVE-PHOSPHORYLATION",
  "HALLMARK-GLYCOLYSIS",
  "HALLMARK-INTERFERON-GAMMA-RESPONSE",
  "HALLMARK-COMPLEMENT",
  "HALLMARK-INFLAMMATORY-RESPONSE",
  "HALLMARK-TNFA-SIGNALING-VIA-NFKB",
  "HALLMARK-IL6-JAK-STAT3-SIGNALING",
  "HALLMARK-ANGIOGENESIS"
)

for (pw in hallmarks) {
  message("Making Fibro plot for ", pw)
  make_Fibro_hallmark_plot(pw)
}

```

##### Format Fix For Publication
###### E2F 
```{r}
box_pw <- "HALLMARK-E2F-TARGETS"

df_box <- FetchData(
  Fibro_ssGSEA_ALLxCell,
  vars = c("CultureCondition", box_pw, "CellLine")
)

colnames(df_box)[2] <- "Score"

Comp_of_Interest <- df_box |> 
  dplyr::filter(
    CellLine == "Fibroblast",
    CultureCondition %in% c("Pattern", "Random", "Control")
  ) |>
  dplyr::mutate(
    CultureCondition = factor(
      CultureCondition,
      levels = c("Pattern", "Random", "Control")
    )
  )

# Stats
pair_res <- pairwise.wilcox.test(
  Comp_of_Interest$Score,
  Comp_of_Interest$CultureCondition,
  p.adjust.method = "BH"
)

get_p <- function(mat, g1, g2) {
  rn <- rownames(mat); cn <- colnames(mat)
  if (g1 %in% rn && g2 %in% cn) return(mat[g1,g2])
  if (g2 %in% rn && g1 %in% cn) return(mat[g2,g1])
  NA_real_
}

comparisons <- list(
  c("Pattern","Random"),
  c("Random","Control"),
  c("Pattern","Control")
)

star_from_p <- function(p){
  if (is.na(p)) return(NA_character_)
  if (p < 1e-4) return("****")
  if (p < 1e-3) return("***")
  if (p < 1e-2) return("**")
  if (p < 0.05) return("*")
  "ns"
}

p_vals <- sapply(comparisons, \(x) get_p(pair_res$p.value,x[1],x[2]))
labels <- sapply(p_vals, star_from_p)

stat_df <- tibble::tibble(
  group1 = sapply(comparisons, `[`, 1),
  group2 = sapply(comparisons, `[`, 2),
  label  = labels
) |> dplyr::filter(!is.na(label), label != "ns")

# y-axis frame 
score_min <- min(Comp_of_Interest$Score, na.rm = TRUE)
score_max <- max(Comp_of_Interest$Score, na.rm = TRUE)
height    <- score_max - score_min
if (height == 0) height <- 1

# Manually anchor bracket stack lower
base_y <- 6
step_y <- 1        

if (nrow(stat_df) > 0)
  stat_df$y.position <- base_y + step_y * (seq_len(nrow(stat_df)) - 1)

ylim_top <- if (nrow(stat_df) > 0)
  max(stat_df$y.position) + 0.05 * height else score_max + 0.1 * height

y_min <- floor(min(score_min, 0) * 2) / 2
y_breaks <- pretty(c(y_min, ylim_top), 5)

plot_title <- hallmark_titles[box_pw]
if (is.na(plot_title)) plot_title <- box_pw

# Plot
FB_FORMATTED_E2F_BoxPlot <- ggplot(
  Comp_of_Interest,
  aes(x = CultureCondition, y = Score)
) +
  geom_violin(
      aes(fill = CultureCondition),
      trim   = FALSE,
      scale  = "width",
      width  = 0.95,
      alpha  = 0.4,
      color  = NA
    ) +
    geom_boxplot(
      aes(fill = CultureCondition),
      width         = 0.3,
      outlier.shape = NA,
      alpha         = 1,
      linewidth     = 0.4,
      color         = "black"
    ) +
    {
      if (nrow(stat_df) > 0) {
        stat_pvalue_manual(
          stat_df,
          label        = "label",
          tip.length   = 0.0,
          bracket.size = 0.3
        )
      } else {
        NULL
      }
    } +
    scale_fill_manual(
      values = c(
        "Pattern" = "#796089",
        "Random"  = "#DD9358",
        "Control" = "#AFABAB"
      ),
      guide = "none"
    ) +
    scale_y_continuous(
      limits = c(y_min, ylim_top),
      breaks = y_breaks,
      expand = c(0, 0)
    ) +
    coord_cartesian(clip = "off") +
    labs(
      title = plot_title,
      x     = NULL,
      y     = "ssGSEA Z-score"
    ) +
    theme_classic(base_size = 11) +
    theme(
      axis.line   = element_line(linewidth = 0.6, color = "black"),
      axis.text   = element_text(size = 7, color = "black"),
      axis.title  = element_text(size = 7, color = "black"),
      plot.title  = element_text(size = 8, hjust = 0.5),
      panel.grid  = element_blank())


# Delete the file if it already exists
if (file.exists("FB_FORMATTED_E2F_BoxPlot.png")) {
  file.remove("FB_FORMATTED_E2F_BoxPlot.png")
}

# Save
ggsave(
  filename = "FB_FORMATTED_E2F_BoxPlot.png",
  plot     = FB_FORMATTED_E2F_BoxPlot,
  width    = 1.8,
  height   = 1.5,
  dpi      = 300,
  units    = "in"
)

FB_FORMATTED_E2F_BoxPlot
```
```{r}
Comp_of_Interest |>
  dplyr::group_by(CultureCondition) |>
  dplyr::summarise(
    n      = dplyr::n(),
    median = median(Score, na.rm = TRUE),
    mean   = mean(Score, na.rm = TRUE)
  )
```


## 7.) Ligand Receptor - LIANA+
```{r}
## Export to move to Python. Had to pop over to Python because this computer/R wouldn't accept the Liana package

# Subsetting only the barcodes that we are anlayzing to minimize resource needs
scPrint2_sub <- subset(
  x = scPrint2_data_MCLN,
  subset = CultureCondition %in% c("Pattern", "Random") &
           PrintPattern %in% c(
             "Pattern_1", "Pattern_2", "Pattern_3",
             "Random_1",  "Random_2",  "Random_3") &
            CellType %in% c("MCF7", "MCF10A", "Fibroblast")
)

# quick sanity check
table(scPrint2_sub$CultureCondition, scPrint2_sub$PrintPattern)
dim(scPrint2_sub)

DefaultAssay(scPrint2_sub) <- "Spatial.008um"

# Pull raw counts
counts_mat <- LayerData(
  object = scPrint2_sub,
  assay  = "Spatial.008um",
  layer  = "counts"
)

dim(counts_mat)

# Write counts in Matrix Market format
Matrix::writeMM(
  obj  = counts_mat,
  file = "C:/Users/helmsh/scPrint2_PR_counts.mtx"
)

# Write gene table
genes_df <- data.frame(
  gene = rownames(counts_mat),
  stringsAsFactors = FALSE
)
write.table(
  genes_df,
  file      = "C:/Users/helmsh/scPrint2_PR_genes.tsv",
  sep       = "\t",
  quote     = FALSE,
  row.names = FALSE
)

# Metadata: keep all columns plus an explicit cell ID
meta <- scPrint2_sub@meta.data
meta$CellID <- rownames(meta)
meta$Condition <- meta$CultureCondition
meta$SampleID  <- meta$PrintPattern

write.csv(
  meta,
  file      = "C:/Users/helmsh/scPrint2_PR_meta.csv",
  row.names = FALSE)

```


# XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

# MOVE TO PYTHON to perform LIANA. 

Bring data back in for visualization 

# XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

## Chord Diagram 
```{r}
# Import edge table results from python
edges_pat  <- read.csv("//wsl.localhost/Ubuntu/home/helmsh/liana_data/scPrint2_Pattern_cellcell_edges.csv")

edges_rand <- read.csv("//wsl.localhost/Ubuntu/home/helmsh/liana_data/scPrint2_Random_cellcell_edges.csv")


# Function to make a cellcell chord diagram 
plot_cellcell_circos <- function(edges, out_png,
                                 min_weight = 2,
                                 cols = c(
                                   "MCF10A"     = "#D15B5D",
                                   "MCF7"       = "#D795D1",
                                   "Fibroblast" = "#718F77"
                                 )) {

  # keep stronger edges
  edges <- subset(edges, weight >= min_weight)
  if (nrow(edges) == 0) stop("No edges left after filtering by min_weight.")

  # cell types present
  cells <- sort(unique(c(edges$source, edges$target)))

  # colors for those cells
  cell_cols <- cols[cells]

  # matrix for chordDiagram
  mat <- xtabs(weight ~ source + target, data = edges)

  # reset circos
  circos.clear()

  # high-res canvas
  png(filename = out_png, width = 5000, height = 5000, res = 800)

  circos.par(
    gap.after    = rep(8, length(cells)),
    start.degree = 90
  )

  chordDiagram(
    x                      = mat,
    directional            = 1,
    direction.type         = "arrows",
    diffHeight             = 0.02,
    grid.col               = cell_cols,
    annotationTrack        = "grid",
    annotationTrackHeight  = mm_h(4),
    transparency           = 0.3
  )

  # outer cell labels
  circos.trackPlotRegion(
    track.index = 1,
    panel.fun = function(x, y) {
      sector_name <- get.cell.meta.data("sector.index")
      ylim        <- get.cell.meta.data("ylim")

      circos.text(
        x          = get.cell.meta.data("xcenter"),
        y          = ylim[2] + mm_y(4),  # a bit outside the ring
        labels     = sector_name,
        facing     = "bending",
        niceFacing = TRUE,
        cex        = 1.6
      )
    },
    bg.border = NA
  )

  dev.off()
  circos.clear()
}


# Pattern
pat_file  <- "Pattern_cellcell_circos.png"

if (file.exists(pat_file)) {
  file.remove(pat_file)
  message("Deleted existing: ", pat_file)
}

plot_cellcell_circos(
  edges   = edges_pat,
  out_png = pat_file
)

# Random
rand_file <- "Random_cellcell_circos.png"

if (file.exists(rand_file)) {
  file.remove(rand_file)
  message("Deleted existing: ", rand_file)
}

plot_cellcell_circos(
  edges   = edges_rand,
  out_png = rand_file
)
```

### Summary values
```{r}
pairwise_delta <- full_join(
  edges_pat  %>% dplyr::rename(weight_pattern = weight),
  edges_rand %>% dplyr::rename(weight_random  = weight),
  by = c("source", "target")
) %>%
  dplyr::mutate(
    weight_pattern = replace_na(weight_pattern, 0),
    weight_random  = replace_na(weight_random,  0),
    delta_pairs    = weight_pattern - weight_random
  ) %>%
  arrange(desc(abs(delta_pairs)))

# Apply the same filter used for visualization
min_weight <- 2
pairwise_delta_f <- pairwise_delta %>%
  filter(weight_pattern >= min_weight | weight_random >= min_weight)

head(pairwise_delta_f, 20)

```



## Pairwise rewiring
```{r}
# Using the same data from the circos plots. Looks at how sender receiver cell pairs change

# Load data from Python
df <- read_csv("//wsl.localhost/Ubuntu/home/helmsh/liana_data/scPrint2_rewiring_dotplot_data.csv")

# Ensure numeric columns and order pairs for plotting
df <- df %>%
  mutate(
    delta     = as.numeric(delta),
    abs_delta = as.numeric(abs_delta)
  ) %>%
  arrange(delta) %>%
  mutate(pair = factor(pair, levels = pair))


SenderReceiver_rewiring_Global <- ggplot(
  df,
  aes(
    x      = delta,
    y      = pair,
    size   = abs_delta,
    color = delta          
  )
) +
  # central line
  geom_vline(xintercept = 0, linewidth = 0.2, color = "gray") +
  
  geom_point(alpha = 0.95, stroke = 0.4) +
  
  scale_x_continuous(
    limits = c(-15, 15),
    breaks = c(-15, -10, -5, 0, 5, 10, 15),
    expand = expansion(mult = 0.05)
  ) +
  coord_cartesian(clip = "off") +
  
  # COLOR = bias (Pattern vs Random)
  scale_color_gradient2(
    low      = "#DD9358",
    mid      = "lightgray",
    high     = "#796089",
    midpoint = 0,
    limits   = c(-15, 15),
    breaks   = c(-15, 0, 15),
    labels   = c("Random", "Neutral", "Pattern"),
    name     = "LigandReceptor\nPair Count Shift\n(Pattern  Random)"
  ) +
  
  # SIZE = magnitude
  scale_size_continuous(
    range  = c(0.2, 7),
    limits = c(0, 15),
    breaks = c(1, 5, 10, 15),
    name   = "Magnitude"
  ) +
  
  # legend order: bias first, magnitude second; solid black magnitude dots
  guides(
    colour = guide_colorbar(order = 1),
    size   = guide_legend(
      order = 2,
      override.aes = list(
        shape  = 16,
        colour = "black",
        fill   = "black",
        alpha  = 1
      )
    )
  ) +
 
  labs(
    x     = "LR Pair Count Difference (Pattern  Random)",
    y     = "Sender  Receiver",
    title = "Sender  Receiver signaling rewiring"
  ) +
  
  theme_classic(base_size = 14) +
  theme(
    plot.title    = element_text(color = "black"),
    plot.subtitle = element_text(color = "black"),
    axis.title    = element_text(color = "black"),
    axis.title.x  = element_text(color = "black", size = 12),
    axis.text     = element_text(color = "black"),
    legend.title  = element_text(color = "black", size = 8),
    legend.text   = element_text(color = "black", size = 8),
    legend.position = "right"
  )

# Remove old file if exists
if (file.exists("SenderReceiver_rewiring_Global.png")) {
  file.remove("SenderReceiver_rewiring_Global.png")
}

# Save
ggsave(
  filename = "SenderReceiver_rewiring_Global.png",
  plot     = SenderReceiver_rewiring_Global,
  width    = 6.5,  
  height   = 6,
  dpi      = 600,
  units    = "in"
)

SenderReceiver_rewiring_Global
```


## Top L-R pairs - Dot Plots
```{r}
# Again, load in Liana results from python 
liana_pat  <- read_csv("//wsl.localhost/Ubuntu/home/helmsh/liana_data/scPrint2_liana_Pattern_rank_aggregate.csv")

liana_rand <- read_csv("//wsl.localhost/Ubuntu/home/helmsh/liana_data/scPrint2_liana_Random_rank_aggregate.csv")
```

```{r}
common_cols <- intersect(colnames(liana_pat), colnames(liana_rand))

df <- bind_rows(
  liana_pat  %>% dplyr::select(all_of(common_cols)) %>% mutate(condition = "Pattern"),
  liana_rand %>% dplyr::select(all_of(common_cols)) %>% mutate(condition = "Random")
) %>%
  dplyr::mutate(
    edge = paste0(source, "  ", target),
    lr_pair = paste0(ligand_complex, "  ", receptor_complex),
    condition = factor(condition, levels = c("Pattern", "Random"))
  )

# choose a consistent set of LR per edge (top 5 per edge per condition, union)
top_lr <- df %>%
  group_by(edge, condition) %>%
  arrange(magnitude_rank, .by_group = TRUE) %>%
  slice_head(n = 5) %>%
  ungroup() %>%
  distinct(edge, lr_pair)

df_plot <- df %>% semi_join(top_lr, by = c("edge","lr_pair"))

# LIANA values are intuitively backwards to me - low strength is best and 1 is worst. So we will mutate to flip
df_plot <- df_plot %>%
  dplyr::mutate(
    interaction_strength = 1 - magnitude_rank,
    interaction_specificity = 1 - specificity_rank
  )
```

### Supplementary figure - global overview 
```{r}
cell_order <- c("MCF10A", "MCF7", "Fibroblast")

df_plot <- df_plot %>%
  mutate(
    source = factor(source, levels = cell_order),
    target = factor(target, levels = cell_order),
    edge = factor(
      edge,
      levels = as.vector(
        outer(cell_order, cell_order, paste, sep = "  "))))


liana_global_dotplot <- ggplot(
  df_plot,
  aes(
    x = condition,
    y = fct_reorder(lr_pair, magnitude_rank, .fun = min),
    color = interaction_strength,
    size  = interaction_specificity
  )
) +
  geom_point(alpha = 0.9) +
  facet_wrap(~ edge, scales = "free_y") +

  scale_color_viridis_c(
    name = "Interaction Score",
    option = "viridis",
    limits = c(0, 1),
    breaks = seq(0, 1, by = 0.2),
    labels = scales::number_format(accuracy = 0.01)
  ) +
  scale_size_continuous(
    name = "Interaction Specificity",
    limits = c(0, 1),
    range = c(1.2, 6),
    breaks = seq(0, 1, by = 0.25),
    labels = scales::number_format(accuracy = 0.01)
  ) +

  ylab("Ligand  Receptor") +
  ggtitle("Global ligandreceptor rewiring across spatial conditions") +

  theme_classic(base_size = 12) +
  theme(
    # facet styling
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", color = "black"),

    # AXES
    axis.title.x = element_blank(),
    axis.title.y = element_text(face = "bold", color = "black"),
    axis.text.x  = element_text(face = "bold", color = "black"),
    axis.text.y  = element_text(color = "black"),
    axis.line.x = element_line(color = "black", linewidth = 0.6),
    axis.line.y = element_line(color = "black", linewidth = 0.6),

    # legends & title
    plot.title   = element_text(face = "bold", color = "black"),
    legend.title = element_text(face = "bold", color = "black"),
    legend.text  = element_text(color = "black")
  )

# Delete the file if it already exists
if (file.exists("liana_global_dotplot.png")) {
  file.remove("liana_global_dotplot.png")
}

# Save
ggsave(
  filename = "liana_global_dotplot.png",
  plot = liana_global_dotplot,
  width = 12, 
  height = 10,  
  dpi = 300,
  units = "in")

liana_global_dotplot
```

### MCF10A -> MCF7 Example
```{r}
### MCF10A -> MCF7 Example
SENDER   <- "MCF10A"
RECEIVER <- "MCF7"
TOP_N    <- 10

df_edge <- df %>%
  dplyr::filter(source == SENDER, target == RECEIVER) %>%
  dplyr::mutate(
    interaction_strength = 1 - magnitude_rank)

# Rank all LR pairs within each condition
pat_ranked <- df_edge %>%
  dplyr::filter(condition == "Pattern") %>%
  dplyr::arrange(magnitude_rank) %>%
  dplyr::distinct(lr_pair, .keep_all = TRUE) %>%
  dplyr::mutate(rank_pat = dplyr::row_number())

rand_ranked <- df_edge %>%
  dplyr::filter(condition == "Random") %>%
  dplyr::arrange(magnitude_rank) %>%
  dplyr::distinct(lr_pair, .keep_all = TRUE) %>%
  dplyr::mutate(rank_rand = dplyr::row_number())


# Build non-overlapping top 10 sets
chosen_pat  <- character(0)
chosen_rand <- character(0)

i     <- 1
max_i <- max(nrow(pat_ranked), nrow(rand_ranked))

while ((length(chosen_pat) < TOP_N | length(chosen_rand) < TOP_N) && i <= max_i) {
  # Pattern
  if (i <= nrow(pat_ranked) && length(chosen_pat) < TOP_N) {
    cand_pat <- pat_ranked$lr_pair[i]
    if (!(cand_pat %in% chosen_pat) && !(cand_pat %in% chosen_rand)) {
      chosen_pat <- c(chosen_pat, cand_pat)
    }
  }

  # Random
  if (i <= nrow(rand_ranked) && length(chosen_rand) < TOP_N) {
    cand_rand <- rand_ranked$lr_pair[i]
    if (!(cand_rand %in% chosen_rand) && !(cand_rand %in% chosen_pat)) {
      chosen_rand <- c(chosen_rand, cand_rand)
    }
  }

  i <- i + 1
}

top_pat <- pat_ranked %>%
  dplyr::filter(lr_pair %in% chosen_pat) %>%
  dplyr::mutate(in_top_pat = TRUE) %>%
  dplyr::select(lr_pair, in_top_pat)

top_rand <- rand_ranked %>%
  dplyr::filter(lr_pair %in% chosen_rand) %>%
  dplyr::mutate(in_top_rand = TRUE) %>%
  dplyr::select(lr_pair, in_top_rand)

top_union <- dplyr::full_join(top_pat, top_rand, by = "lr_pair") %>%
  dplyr::mutate(
    in_top_pat  = ifelse(is.na(in_top_pat),  FALSE, in_top_pat),
    in_top_rand = ifelse(is.na(in_top_rand), FALSE, in_top_rand),
    top_class = dplyr::case_when(
      in_top_pat  & !in_top_rand ~ "Top 10 in Pattern",
      !in_top_pat & in_top_rand  ~ "Top 10 in Random",
      TRUE                      ~ "Not in either"
    )
  )


# Score per condition for every LR in union
pat_strength <- df_edge %>%
  dplyr::filter(condition == "Pattern") %>%
  dplyr::group_by(lr_pair) %>%
  dplyr::summarise(
    str_pat = max(interaction_strength, na.rm = TRUE),
    .groups = "drop"
  )

rand_strength <- df_edge %>%
  dplyr::filter(condition == "Random") %>%
  dplyr::group_by(lr_pair) %>%
  dplyr::summarise(
    str_rand = max(interaction_strength, na.rm = TRUE),
    .groups = "drop"
  )

df_plot <- top_union %>%
  dplyr::left_join(pat_strength,  by = "lr_pair") %>%
  dplyr::left_join(rand_strength, by = "lr_pair") %>%
  dplyr::mutate(
    str_pat        = ifelse(is.na(str_pat),  0, str_pat),
    str_rand       = ifelse(is.na(str_rand), 0, str_rand),
    delta_strength = str_pat - str_rand
  )

# Ordering: biggest absolute rewiring at top
df_plot <- df_plot %>%
  dplyr::mutate(abs_delta = abs(delta_strength)) %>%
  dplyr::arrange(dplyr::desc(abs_delta)) %>%
  dplyr::mutate(lr_pair = factor(lr_pair, levels = rev(unique(lr_pair)))) %>%
  dplyr::mutate(
    top_class = factor(
      top_class,
      levels = c("Top 10 in Pattern", "Top 10 in Random", "Not in either")
    )
  )


# Plot Formatting
df_plot <- df_plot %>%
  dplyr::mutate(
    top_class = factor(
      top_class,
      levels = c("Top 10 in Pattern", "Top 10 in Random")
    )
  )

outline_cols <- c(
  "Top 10 in Pattern" = "#796089",  
  "Top 10 in Random"  = "#DD9358" 
)

lollipop_plot_nooverlap <- ggplot(
  df_plot,
  aes(
    x     = delta_strength,
    y     = lr_pair,
    size  = abs_delta,
    fill  = delta_strength,  
    color = top_class 
  )
) +
  geom_vline(xintercept = 0, linewidth = 0.2, color = "gray") +
  geom_point(shape = 21, stroke = 1.5, alpha = 0.95) +

  scale_size_continuous(
    range  = c(0.1, 7),
    limits = c(0.0, 1),
    breaks = c(0, 0.1, 0.25, 0.5, 0.75, 1),
    labels = scales::number_format(accuracy = 0.01),
    name   = "Magnitude"
  ) +

  scale_fill_gradient2(
    low      = "#DD9358",
    mid      = "lightgray",
    high     = "#796089",
    midpoint = 0,
    limits   = c(-1, 1),
    breaks   = c(-1, 0, 1),
    labels   = c("Random", "Neutral", "Pattern"),
    name     = "Interaction Score Bias \n(Pattern vs Random)"
  ) +

  scale_color_manual(
    values = outline_cols,
    name   = "Top Ligand-Receptor \nPair Source"
  ) +

  guides(
    color = guide_legend(order = 1),          # first: top pair source
    fill  = guide_colorbar(order = 2),        # second: bias colorbar
    size  = guide_legend(                     # third: magnitude dots
      order = 3,
      override.aes = list(
        shape  = 16,
        colour = "black",
        fill   = "black",
        alpha  = 1
      )
    )
  ) +
  
  scale_x_continuous(
    limits = c(-1, 0.25),
    breaks = seq(-1, 0.25, by = 0.25),
    labels = scales::number_format(accuracy = 0.01),
    expand = expansion(mult = 0.05)
  ) +
  coord_cartesian(clip = "off") +
  
  labs(
    title    = paste0("Rewired ligandreceptor signaling: ", SENDER, " \u2192 ", RECEIVER),
    subtitle = paste0("Non-overlapping Top ", TOP_N, " LR pairs in Pattern vs Random"),
    x        = "Interaction Score Difference (Pattern  Random)",
    y        = "Ligand  Receptor"
  ) +
  
  theme_classic(base_size = 12) +
  theme(
    plot.title       = element_text(color = "black"),
    plot.subtitle    = element_text(color = "black"),
    axis.title       = element_text(color = "black"),
    axis.text        = element_text(color = "black"),
    legend.title     = element_text(color = "black", size = 8),
    legend.text      = element_text(color = "black", size = 8),
    legend.position  = "right",
    legend.key.height = unit(0.5, "cm")
  )

# Delete the file if it already exists
if (file.exists("MCF10A_to_MCF7_rewiring_Unique_lollipop.png")) {
  file.remove("MCF10A_to_MCF7_rewiring_Unique_lollipop.png")
}

ggsave(
  filename = "MCF10A_to_MCF7_rewiring_Unique_lollipop.png",
  plot     = lollipop_plot_nooverlap,
  width    = 7,
  height   = 6,
  dpi      = 600,
  units    = "in"
)

lollipop_plot_nooverlap

```

### Fibroblast -> MCF10A
```{r}
SENDER   <- "Fibroblast"
RECEIVER <- "MCF10A"
TOP_N    <- 10

df_edge <- df %>%
  dplyr::filter(source == SENDER, target == RECEIVER) %>%
  dplyr::mutate(
    interaction_strength = 1 - magnitude_rank
  )

# Rank all LR pairs within each condition
pat_ranked <- df_edge %>%
  dplyr::filter(condition == "Pattern") %>%
  dplyr::arrange(magnitude_rank) %>%
  dplyr::distinct(lr_pair, .keep_all = TRUE) %>%
  dplyr::mutate(rank_pat = dplyr::row_number())

rand_ranked <- df_edge %>%
  dplyr::filter(condition == "Random") %>%
  dplyr::arrange(magnitude_rank) %>%
  dplyr::distinct(lr_pair, .keep_all = TRUE) %>%
  dplyr::mutate(rank_rand = dplyr::row_number())

# Build non-overlapping top 10 sets
chosen_pat  <- character(0)
chosen_rand <- character(0)

i     <- 1
max_i <- max(nrow(pat_ranked), nrow(rand_ranked))

while ((length(chosen_pat) < TOP_N | length(chosen_rand) < TOP_N) && i <= max_i) {
  # Pattern
  if (i <= nrow(pat_ranked) && length(chosen_pat) < TOP_N) {
    cand_pat <- pat_ranked$lr_pair[i]
    if (!(cand_pat %in% chosen_pat) && !(cand_pat %in% chosen_rand)) {
      chosen_pat <- c(chosen_pat, cand_pat)
    }
  }

  # Random
  if (i <= nrow(rand_ranked) && length(chosen_rand) < TOP_N) {
    cand_rand <- rand_ranked$lr_pair[i]
    if (!(cand_rand %in% chosen_rand) && !(cand_rand %in% chosen_pat)) {
      chosen_rand <- c(chosen_rand, cand_rand)
    }
  }

  i <- i + 1
}

top_pat <- pat_ranked %>%
  dplyr::filter(lr_pair %in% chosen_pat) %>%
  dplyr::mutate(in_top_pat = TRUE) %>%
  dplyr::select(lr_pair, in_top_pat)

top_rand <- rand_ranked %>%
  dplyr::filter(lr_pair %in% chosen_rand) %>%
  dplyr::mutate(in_top_rand = TRUE) %>%
  dplyr::select(lr_pair, in_top_rand)

top_union <- dplyr::full_join(top_pat, top_rand, by = "lr_pair") %>%
  dplyr::mutate(
    in_top_pat  = ifelse(is.na(in_top_pat),  FALSE, in_top_pat),
    in_top_rand = ifelse(is.na(in_top_rand), FALSE, in_top_rand),
    top_class = dplyr::case_when(
      in_top_pat  & !in_top_rand ~ "Top 10 in Pattern",
      !in_top_pat & in_top_rand  ~ "Top 10 in Random",
      TRUE                      ~ "Not in either"
    )
  )

# Score per condition for every LR in union
pat_strength <- df_edge %>%
  dplyr::filter(condition == "Pattern") %>%
  dplyr::group_by(lr_pair) %>%
  dplyr::summarise(
    str_pat = max(interaction_strength, na.rm = TRUE),
    .groups = "drop"
  )

rand_strength <- df_edge %>%
  dplyr::filter(condition == "Random") %>%
  dplyr::group_by(lr_pair) %>%
  dplyr::summarise(
    str_rand = max(interaction_strength, na.rm = TRUE),
    .groups = "drop"
  )

df_plot <- top_union %>%
  dplyr::left_join(pat_strength,  by = "lr_pair") %>%
  dplyr::left_join(rand_strength, by = "lr_pair") %>%
  dplyr::mutate(
    str_pat        = ifelse(is.na(str_pat),  0, str_pat),
    str_rand       = ifelse(is.na(str_rand), 0, str_rand),
    delta_strength = str_pat - str_rand
  )

# Ordering: biggest absolute rewiring at top
df_plot <- df_plot %>%
  dplyr::mutate(abs_delta = abs(delta_strength)) %>%
  dplyr::arrange(dplyr::desc(abs_delta)) %>%
  dplyr::mutate(lr_pair = factor(lr_pair, levels = rev(unique(lr_pair)))) %>%
  dplyr::mutate(
    top_class = factor(
      top_class,
      levels = c("Top 10 in Pattern", "Top 10 in Random", "Not in either")
    )
  )

# Plot formatting
df_plot <- df_plot %>%
  dplyr::mutate(
    top_class = factor(
      top_class,
      levels = c("Top 10 in Pattern", "Top 10 in Random")
    )
  )

outline_cols <- c(
  "Top 10 in Pattern" = "#796089",  # purple
  "Top 10 in Random"  = "#DD9358"   # orange
)

lollipop_plot_nooverlap_FBtoMCF10A <- ggplot(
  df_plot,
  aes(
    x     = delta_strength,
    y     = lr_pair,
    size  = abs_delta,
    fill  = delta_strength,
    color = top_class
  )
) +
  geom_vline(xintercept = 0, linewidth = 0.2, color = "gray") +
  geom_point(shape = 21, stroke = 1.5, alpha = 0.95) +

  scale_size_continuous(
    range  = c(0.1, 7),
    limits = c(0.0, 1),
    breaks = c(0, 0.1, 0.25, 0.5, 0.75, 1),
    labels = scales::number_format(accuracy = 0.01),
    name   = "Magnitude"
  ) +

  scale_fill_gradient2(
    low      = "#DD9358",
    mid      = "lightgray",
    high     = "#796089",
    midpoint = 0,
    limits   = c(-1, 1),
    breaks   = c(-1, 0, 1),
    labels   = c("Random", "Neutral", "Pattern"),
    name     = "Interaction Score Bias \n(Pattern vs Random)"
  ) +

  scale_color_manual(
    values = outline_cols,
    name   = "Top Ligand-Receptor \nPair Source"
  ) +

  guides(
    color = guide_legend(order = 1),          # first: top pair source
    fill  = guide_colorbar(order = 2),        # second: bias colorbar
    size  = guide_legend(                     # third: magnitude dots
      order = 3,
      override.aes = list(
        shape  = 16,
        colour = "black",
        fill   = "black",
        alpha  = 1
      )
    )
  ) +
  
  scale_x_continuous(
    limits = c(-0.25, 1),
    breaks = seq(-0.25, 1, by = 0.25),
    labels = scales::number_format(accuracy = 0.01),
    expand = expansion(mult = 0.05)
  ) +
  coord_cartesian(clip = "off") +
  
  labs(
    title    = paste0("Rewired ligandreceptor signaling: ", SENDER, " \u2192 ", RECEIVER),
    subtitle = paste0("Non-overlapping Top ", TOP_N, " LR pairs in Pattern vs Random"),
    x        = "Interaction Score Difference (Pattern  Random)",
    y        = "Ligand  Receptor"
  ) +
  
  theme_classic(base_size = 12) +
  theme(
    plot.title       = element_text(color = "black"),
    plot.subtitle    = element_text(color = "black"),
    axis.title       = element_text(color = "black"),
    axis.text        = element_text(color = "black"),
    legend.title     = element_text(color = "black", size = 8),
    legend.text      = element_text(color = "black", size = 8),
    legend.position  = "right",
    legend.key.height = unit(0.5, "cm")
  )

# Delete the file if it already exists
if (file.exists("FB_to_MCF10A_rewiring_Unique_lollipop.png")) {
  file.remove("FB_to_MCF10A_rewiring_Unique_lollipop.png")
}

ggsave(
  filename = "FB_to_MCF10A_rewiring_Unique_lollipop.png",
  plot     = lollipop_plot_nooverlap_FBtoMCF10A,
  width    = 7,
  height   = 6,
  dpi      = 600,
  units    = "in"
)

lollipop_plot_nooverlap_FBtoMCF10A
```

## Sankey Plot - made in Python


# ------------------------------------------------------------------------------
```{r}
sessionInfo()
```